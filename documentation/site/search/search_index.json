{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C++ moderne Ce document en PDF : c++-moderne.pdf C++ C++ est un langage de programmation compil\u00e9 permettant la programmation sous de multiples paradigmes (comme la programmation proc\u00e9durale, orient\u00e9e objet ou g\u00e9n\u00e9rique). Ses bonnes performances, et sa compatibilit\u00e9 avec le C en font un des langages de programmation les plus utilis\u00e9s dans les applications o\u00f9 la performance est critique. Cr\u00e9\u00e9 initialement par Bjarne Stroustrup dans les ann\u00e9es 1980, le langage C++ est aujourd'hui normalis\u00e9 par l'ISO. Sa premi\u00e8re normalisation date de 1998 (ISO/CEI 14882:1998), ensuite amend\u00e9e par l'erratum technique de 2003 (ISO/CEI 14882:2003). Une importante mise \u00e0 jour a \u00e9t\u00e9 ratifi\u00e9e et publi\u00e9e par l'ISO en septembre 2011 sous le nom de ISO/IEC 14882:2011, ou C++11 . Depuis, des mises \u00e0 jour sont publi\u00e9es r\u00e9guli\u00e8rement : en 2014 (ISO/CEI 14882:2014 ou C++14 ) puis en 2017 (ISO/CEI 14882:2017 ou C++17 ). [source : wikipedia.org ] Les changements du langage C++ concernent aussi bien le langage initial que la biblioth\u00e8que standard. Remarque : La biblioth\u00e8que standard du C++ ( C++ Standard Library ) est une biblioth\u00e8que de classes et de fonctions standardis\u00e9es selon la norme ISO pour le langage C++. Elle contient aussi la biblioth\u00e8que standard du C. Une des principales briques de la biblioth\u00e8que standard du C++ est sans aucun doute la STL ( Standard Template Library ), \u00e0 tel point qu'il y a souvent confusion entre les deux. Dans l'index de popularit\u00e9 des langages TIOBE , le C repr\u00e9sente 16,2 % (premi\u00e8re place) et le C++ 7,6 % (quatri\u00e8me place) en novembre 2020. Liens : www.cplusplus.com Comit\u00e9 du standard C++ C++ moderne Le C++ moderne est apparu avec la mise \u00e0 jour C++11. Les standards C++11, 14, 17 et bient\u00f4t 20 apportent de nombreuses fonctionnalit\u00e9s : gestion automatique de la m\u00e9moire via des pointeurs intelligents ( Smart Pointers ), d\u00e9duction de type automatique \u00e0 la d\u00e9claration via auto , etc ... L'impl\u00e9mentation des standards C++ va d\u00e9pendre du compilateur utilis\u00e9, de sa version et des options invoqu\u00e9es. Exemple sous Ubuntu 18.04 : $ g++ --version g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 $ man g++ ... g++ [-std=standard] ... ... -std= Determine the language standard. This option is currently only supported when compiling C or C++. ... c11 c1x iso9899:2011 ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name c1x is deprecated. c++11 c++0x The 2011 ISO C++ standard plus amendments. The name c++0x is deprecated. c++14 c++1y The 2014 ISO C++ standard plus amendments. The name c++1y is deprecated. gnu++14 gnu++1y GNU dialect of -std=c++14. This is the default for C++ code. The name gnu++1y is deprecated. c++1z The next revision of the ISO C++ standard, tentatively planned for 2017. Support is highly experimental, and will almost certainly change in incompatible ways in future releases. Remarque : il est possible de d\u00e9finir le standard utilis\u00e9 pour le compilateur C++ dans un projet Qt . Pour cela, il suffit de l'indiquer dans la variable CONFIG de son fichier .pro : CONFIG += c++11 Les exemples https://github.com/tvaira/cpp-moderne C++11 Lien : C++11 Les types et les variables Le langage C++ est dit fortement typ\u00e9. Chaque variable poss\u00e8de un type. Une d\u00e9finition est compos\u00e9e de : un type pour d\u00e9finir la convention d'interpr\u00e9tation des valeurs possibles un objet qui contient en m\u00e9moire la valeur d'un type une valeur une variable qui est le nom de l'objet Chaque type est directement li\u00e9 \u00e0 une architecture mat\u00e9rielle et poss\u00e8de une taille fixe. La taille d'un objet et/ou d'un type est obtenue avec l'op\u00e9rateur sizeof . L'op\u00e9rateur typeid() (dans type_info ) permet lui d'obtenir le type d'une valeur \u00e0 l'ex\u00e9cution : #include <iostream> #include <string> #include <typeinfo> using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} private : string str ; }; int main () { int i = 10 ; int * pi = & i ; string s = \"hello\" ; cout << \"i : \" << typeid ( i ). name () << '\\n' ; cout << \"&i : \" << typeid ( & i ). name () << '\\n' ; cout << \"pi : \" << typeid ( pi ). name () << '\\n' ; cout << \"*pi : \" << typeid ( * pi ). name () << '\\n' ; cout << \"s : \" << typeid ( s ). name () << '\\n' ; auto booleen = false ; // bool auto f = 1.5 ; // double cout << \"booleen : \" << typeid ( booleen ). name () << '\\n' ; cout << \"f : \" << typeid ( f ). name () << '\\n' ; Foo foo ( s ); cout << \"foo : \" << typeid ( foo ). name () << '\\n' ; return 0 ; } Remarque : Il existe un moyen d'ins\u00e9rer des cha\u00eenes de caract\u00e8res complexes dans le code source sans le formatter avec R\"(raw_string)\" . Ceci est pratique avec des cha\u00eenes qui contiennent des guillemets \" et/ou des antislash \\ . Lien : string_literal #include <iostream> using namespace std ; int main () { string str1 = \"<a href= \\\" file \\\" >C: \\\\ Program Files \\\\ </a>\" ; // avant string str2 = R \" ( <a href=\"file\">C:\\Program Files\\</a> ) \" ; // C++11 cout << \"str1 = \" << str1 << endl ; cout << \"str2 = \" << str2 << endl ; return 0 ; } Initialisation Avant d'\u00eatre utilis\u00e9, un objet doit \u00eatre initialis\u00e9. Il existe l'op\u00e9rateur = , les crochets {} ou les parenth\u00e8ses () comme initialiseurs universels : int a = 10 ; int b ( 20 ); int t [ 3 ] = { 1 , 2 , 3 }; Remarque : Le nouveau standard ISO a introduit une syntaxe d'initialisation uniforme avec les accolades {} . int a { 10 }; int b { 20 }; int t [ 3 ] { 1 , 2 , 3 }; std :: vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; En C++03, il est possible d'assigner une valeur par d\u00e9faut aux attributs statiques et constantes directement dans le fichier d'en-t\u00eate. C++11 \u00e9tend cette possibilit\u00e9 aux attributs des classes : #include <iostream> using namespace std ; class X { public : X () {} explicit X ( int valeur ) : valeur ( valeur ) {} int getValeur () const { return valeur ; } private : int valeur = 1 ; // pour tous les constructeurs }; int main () { X x1 ; X x2 ( 2 ); cout << \"x1 = \" << x1 . getValeur () << \" (\" << sizeof ( x1 ) << \" octets)\" << endl ; cout << \"x2 = \" << x2 . getValeur () << \" (\" << sizeof ( x2 ) << \" octets)\" << endl ; //cout << \"Membre valeur -> \" << sizeof(X::valeur) << \" octets\" << endl; // si membre public return 0 ; } auto Il est aussi possible de laisser le compilateur d\u00e9duire le type \u00e0 la compilation en utilisant le mot-cl\u00e9 auto : #include <iostream> using namespace std ; int main () { auto booleen = false ; // bool auto ch = 'c' ; // char auto i = 10 ; // int auto f = 1.5 ; // double auto s = \"string\" ; // char * cout << \"booleen = \" << booleen << \" (\" << sizeof ( booleen ) << \" octet)\" << endl ; cout << std :: boolalpha << \"booleen = \" << booleen << \" (\" << sizeof ( booleen ) << \" octet)\" << endl ; cout << \"ch = \" << ch << \" (\" << sizeof ( ch ) << \" octet)\" << endl ; cout << \"i = \" << i << \" (\" << sizeof ( i ) << \" octets)\" << endl ; cout << \"f = \" << f << \" (\" << sizeof ( f ) << \" octets)\" << endl ; cout << \"s = \" << s << \" (\" << sizeof ( s ) << \" octets)\" << endl ; vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; cout << \"v : \" ; for ( auto it = v . begin (); it != v . end (); ++ it ) { cout << * it << ' ' ; } cout << '\\n' ; // ou avec range-for cout << \"v : \" ; for ( auto i : v ) // i est un int { cout << i << ' ' ; } cout << '\\n' ; return 0 ; } Membre mutable Dans une fonction const , il est impossible de modifier un attribut (une variable membre) sauf si ce membre est pr\u00e9fix\u00e9 du mot-cl\u00e9 mutable . Remarque : Un membre mutable n'est jamais const ! Lien : mutable specifier #include <iostream> using namespace std ; class X { public : X () : x ( 0 ) {} int getX () const { return x ; }; void foo () const ; private : mutable int x = 0 ; }; void X::foo () const { ++ x ; } int main () { X unObjetX ; cout << \"x = \" << unObjetX . getX () << endl ; unObjetX . foo (); cout << \"x = \" << unObjetX . getX () << endl ; return 0 ; } Les pointeurs Il faut maintenant utiliser nullptr \u00e0 la place de 0 ou NULL pour initialiser un pointeur : #include <iostream> using namespace std ; int main () { int j = 20 ; int * pj = nullptr ; cout << \"j = \" << j << \" (\" << sizeof ( j ) << \" octets)\" << endl ; cout << \"&j = \" << & j << \" (\" << sizeof ( & j ) << \" octets)\" << endl ; cout << \"pj = \" << pj << \" (\" << sizeof ( pj ) << \" octets)\" << endl ; if ( pj != nullptr ) cout << \"*pj = \" << * pj << \" (\" << sizeof ( * pj ) << \" octets)\" << endl ; pj = & j ; * pj = 30 ; cout << \"j = \" << j << \" (\" << sizeof ( j ) << \" octets)\" << endl ; cout << \"&j = \" << & j << \" (\" << sizeof ( & j ) << \" octets)\" << endl ; cout << \"pj = \" << pj << \" (\" << sizeof ( pj ) << \" octets)\" << endl ; if ( pj ) cout << \"*pj = \" << * pj << \" (\" << sizeof ( * pj ) << \" octets)\" << endl ; return 0 ; } Les pointeurs intelligents Un pointeur intelligent ( smart pointer ) est un type abstrait de donn\u00e9es qui simule le comportement d'un pointeur en y ajoutant des fonctionnalit\u00e9s telles que la lib\u00e9ration automatique de la m\u00e9moire allou\u00e9e ou la v\u00e9rification des bornes. En C++11, les pointeurs intelligents sont impl\u00e9ment\u00e9s \u00e0 l'aide de templates qui \"imitent\" le comportement des pointeurs gr\u00e2ce \u00e0 la surcharge des op\u00e9rateurs, tout en fournissant des algorithmes de gestion m\u00e9moire. unique_ptr est une classe qui poss\u00e8de un membre qui pointe sur une ressource (objet) non partageable. unique_ptr g\u00e8re l'objet point\u00e9 en devenant responsable de sa suppression lorsqu'il passe hors de port\u00e9e. Lien : unique_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { unique_ptr < Point > p1 ( new Point ( 10 , 5 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; cout << p1 -> getX () << \",\" << p1 -> getY () << endl ; unique_ptr < Point > p2 ( move ( p1 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; unique_ptr < Point > p3 ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; //p3 = p2; // erreur ! return 0 ; } Les shared_ptr impl\u00e9mentent le comptage de r\u00e9f\u00e9rences, ce qui permet de partager l'objet poss\u00e9d\u00e9 par un shared_ptr entre plusieurs shared_ptr sans se soucier de comment lib\u00e9rer la m\u00e9moire associ\u00e9e. Lorsque le dernier shared_ptr est d\u00e9truit, l'objet point\u00e9 est \u00e9galement d\u00e9truit. Lien : shared_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { shared_ptr < Point > p1 ( new Point ( 10 , 5 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p1 : \" << p1 . use_count () << endl ; cout << p1 -> getX () << \",\" << p1 -> getY () << endl ; shared_ptr < Point > p2 ( move ( p1 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p1 : \" << p1 . use_count () << endl ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p2 : \" << p2 . use_count () << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; shared_ptr < Point > p3 ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p3 : \" << p3 . use_count () << endl ; p3 = p2 ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p2 : \" << p2 . use_count () << endl ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p3 : \" << p3 . use_count () << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; cout << p3 -> getX () << \",\" << p3 -> getY () << endl ; return 0 ; } Les weak_ptr permettent de voir et d'acc\u00e9der \u00e0 une ressource (objet) poss\u00e9d\u00e9e par un shared_ptr mais n'ont aucune influence sur la destruction de ce dernier. Ils servent principalement \u00e0 s'affranchir du probl\u00e8me des r\u00e9f\u00e9rences circulaires. Lien : weak_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { shared_ptr < Point > p1 ( new Point ( 10 , 5 )); weak_ptr < Point > wp1 ; weak_ptr < Point > wp2 ( wp1 ); weak_ptr < Point > wp3 ( p1 ); cout << \"use_count wp1 : \" << wp1 . use_count () << '\\n' ; cout << \"use_count wp2 : \" << wp2 . use_count () << '\\n' ; cout << \"use_count wp3 : \" << wp3 . use_count () << '\\n' ; return 0 ; } Les \u00e9num\u00e9rations De mani\u00e8re g\u00e9n\u00e9rale, les \u00e9num\u00e9rations permettent de grouper des ensembles de valeurs dans un type distinct. Il y a quelques limitations (donc probl\u00e8mes !) dans l'utilisation du type enum : #include <iostream> using namespace std ; int main () { // Probl\u00e8me n\u00b01 : Deux \u00e9num\u00e9rations ne peuvent pas partager les m\u00eames noms enum Genre { Masculin , Femimin }; enum GenrePersonne { Masculin , Femimin }; // error: redeclaration of 'Masculin' Genre genre = Masculin ; GenrePersonne genrePersonne = Femimin ; cout << \"genre = \" << genre << endl ; cout << \"genrePersonne = \" << genrePersonne << endl ; // Probl\u00e8me n\u00b02 : Aucune variable ne peut avoir un nom d\u00e9j\u00e0 utilis\u00e9 dans une \u00e9num\u00e9ration int Masculin = 10 ; // error: 'int Masculin' redeclared as different kind of symbol cout << \"Masculin = \" << Masculin << endl ; // Probl\u00e8me n\u00b03 : Les \u00e9num\u00e9rations ne sont pas un type compl\u00e9tement s\u00e9curis\u00e9 enum Couleur { Rouge , Vert , Bleu }; Couleur couleur = Rouge ; if ( genre == couleur ) //warning: comparison between 'enum main()::Genre' and 'enum main()::Couleur' cout << \"\u00c9gal !\" ; return 0 ; } C++11 a introduit des classes enum (appel\u00e9es \u00e9num\u00e9rations \u00e9tendues) qui rendent les \u00e9num\u00e9rations fortement typ\u00e9es. L'\u00e9num\u00e9ration de classe ne permet pas la conversion implicite en int et ne compare pas non plus les \u00e9num\u00e9rateurs de diff\u00e9rentes \u00e9num\u00e9rations. Lien : enum Syntaxe : enum class name { enumerator = constexpr , enumerator = constexpr , ... } // constexpr = 0 par d\u00e9faut enum class name : type { enumerator = constexpr , enumerator = constexpr , ... } enum class name ; // int par d\u00e9faut enum class name : type ; Exemple : #include <iostream> using namespace std ; int main () { enum class Genre { Masculin , Femimin }; enum class GenrePersonne { Masculin , Femimin }; Genre genre = Genre :: Masculin ; GenrePersonne genrePersonne = GenrePersonne :: Femimin ; cout << \"genre = \" << int ( genre ) << endl ; cout << \"genrePersonne = \" << int ( genrePersonne ) << endl ; int Masculin = 10 ; cout << \"Masculin = \" << Masculin << endl ; /*enum class Couleur { Rouge, Vert, Bleu }; Couleur couleur = Couleur::Rouge; if (genre == couleur) // error: no match for 'operator==' (operand types are 'main()::Genre' and 'main()::Couleur') cout << \"\u00c9gal !\";*/ return 0 ; } decltype Le mot-cl\u00e9 decltype , introduit dans C++11, permet de d\u00e9finir une expression pour exprimer une d\u00e9claration de type. decltype \u00ab retourne \u00bb un type. Lien : decltype #include <iostream> using namespace std ; struct X { int i ; double d ; }; int main () { X x ; decltype ( x ) y ; // le type de y est X decltype ( x . i ) e ; // le type de e est int return 0 ; } Remarque : decltype est notamment int\u00e9ressant dans l'\u00e9criture de biblioth\u00e8ques g\u00e9n\u00e9riques \u00e0 base de templates. Sinon il est fort probable que vous n'ayez pas \u00e0 vous en servir. Les litt\u00e9raux utilisateur C++ fournit un certain nombre de litt\u00e9raux. Les caract\u00e8res 12.5 sont un litt\u00e9ral qui est r\u00e9solu par le compilateur comme un type double . Avec l'ajout du suffixe f ( 12.5f ) le compilateur interpr\u00e9tera la valeur comme un type float . Les modificateurs de suffixe (comme U pour unsigned ou L pour long ) pour les litt\u00e9raux sont fix\u00e9s par la sp\u00e9cification C++. \u00c0 partir de C++11, il est possible de d\u00e9finir ses propres litt\u00e9raux afin de fournir des suffixes syntaxiques qui am\u00e9liore la lisibilit\u00e9 et renforce la s\u00e9curit\u00e9 des types. Lien : user_literal La biblioth\u00e8que standard a elle-m\u00eame d\u00e9fini des litt\u00e9raux pour std::complex et pour les unit\u00e9s dans les op\u00e9rations de temps dans std::chrono : complex < double > n = ( 2.0 + 3.0 i ) * 4 ; cout << \"n = (2 + 3i) x 4\" << endl ; cout << \"n = \" << n << endl ; cout << \"partie r\u00e9elle de n = \" << n . real () << endl ; cout << \"partie imaginaire de n = \" << n . imag () << endl ; cout << endl ; auto recordDuMonde = 2 h + 1 min + 39 s ; cout << \"Record du monde du Marathon : 2 h 01 min 39 s (Eliud Kipchoge en 2018)\" << endl ; cout << \"recordDuMonde = \" << recordDuMonde . count () << \" s\" << endl ; Liens : complex chrono C++ 11 permet donc \u00e0 l'utilisateur de d\u00e9finir de nouveaux types de modificateurs litt\u00e9raux qui construiront des objets bas\u00e9s sur la cha\u00eene de caract\u00e8res que le litt\u00e9ral modifie. La transformation des litt\u00e9raux est red\u00e9finie en deux phases distinctes : raw (brut) et cooked (pr\u00e9par\u00e9). Un litt\u00e9ral raw est une s\u00e9quence de caract\u00e8res d'un type sp\u00e9cifique, tandis que le litt\u00e9ral cooked est d'un type distinct. Le litt\u00e9ral 1234 , en tant que litt\u00e9ral raw , est la s\u00e9quence de caract\u00e8res '1', '2', '3' et '4'. En tant que litt\u00e9ral cooked , il s'agit de l'entier 1234 . Le litt\u00e9ral 0xA est '0', 'x', 'A' soit l'entier 10 . Liens : raw cooked Tous les litt\u00e9raux d\u00e9finis par l'utilisateur seront des suffixes . La d\u00e9finition de litt\u00e9raux de pr\u00e9fixe n'est pas possible. Tous les suffixes commen\u00e7ant par n'importe quel caract\u00e8re sauf le trait de soulignement ( _ ) sont r\u00e9serv\u00e9s par la norme. Ainsi, tous les litt\u00e9raux d\u00e9finis par l'utilisateur doivent avoir des suffixes commen\u00e7ant par un trait de soulignement ( _ ). Les litt\u00e9raux utilisateur sont d\u00e9finis via un op\u00e9rateur litt\u00e9ral qui se nomme operator \"\" . en.wikipedia.org Pour les litt\u00e9raux num\u00e9riques, le type du litt\u00e9ral est unsigned long long pour les litt\u00e9raux entiers ou long double pour les litt\u00e9raux \u00e0 virgule flottante. ( Remarque : il n'est pas n\u00e9cessaire d'utiliser des types int\u00e9graux sign\u00e9s car un litt\u00e9ral avec un pr\u00e9fixe de signe est analys\u00e9 comme une expression contenant le signe en tant qu'op\u00e9rateur de pr\u00e9fixe unaire operator - , qu'il est possible de surcharger, et le nombre non sign\u00e9.) On va d\u00e9finir une classe Temperature . Il sera alors possible de d\u00e9finir un litt\u00e9ral pour les degr\u00e9s Celsius et un autre pour les Fahrenheit. Ensuite, on sera forc\u00e9 d'exprimer explicitement l'unit\u00e9 de mesure en \u00e9crivant par exemple : auto t1 = 36.5_celsius ou auto t2 = 32.0_fahrenheit . #include <iostream> using namespace std ; class Temperature { private : long double temperature = { 0 }; // en celsius explicit Temperature ( long double valeur ) : temperature ( valeur ) { } friend Temperature operator \"\" _celsius ( long double valeur ); // pour une valeur en virgule flottante friend Temperature operator \"\" _celsius ( unsigned long long valeur ); // pour une valeur enti\u00e8re friend Temperature operator \"\" _fahrenheit ( long double valeur ); friend Temperature operator \"\" _kelvin ( long double valeur ); public : constexpr static long double zero_absolu = 273.15 ; // en celsius long double celsius () { return temperature ; } long double fahrenheit () { return ( temperature * 9. / 5. ) + 32. ; } long double kelvin () { return ( temperature + Temperature :: zero_absolu ); } Temperature operator + ( Temperature t ) { return Temperature ( celsius () + t . celsius ()); } friend Temperature operator - ( Temperature t ); }; Temperature operator \"\" _celsius ( long double valeur ) // pour une valeur en virgule flottante { return Temperature ( valeur ); } Temperature operator \"\" _celsius ( unsigned long long valeur ) // pour une valeur enti\u00e8re { return Temperature ( double ( valeur )); } Temperature operator \"\" _fahrenheit ( long double valeur ) { return Temperature (( 5. / 9. ) * ( valeur - 32. )); } Temperature operator \"\" _kelvin ( long double valeur ) { return Temperature ( valeur - Temperature :: zero_absolu ); } Temperature operator - ( Temperature t ) { return Temperature (( -1. ) * t . celsius ()); } int main () { Temperature zeroCelsius = 32. _fahrenheit ; //Temperature zeroCelsius = 0_celsius; cout << \"zeroCelsius = \" << zeroCelsius . celsius () << \"C \" << zeroCelsius . kelvin () << \"K \" << zeroCelsius . fahrenheit () << \"F \" << endl ; Temperature zeroAbsolu = 0. _kelvin ; cout << \"zeroAbsolu = \" << zeroAbsolu . celsius () << \"C \" << zeroAbsolu . kelvin () << \"K \" << zeroAbsolu . fahrenheit () << \"F \" << endl ; Temperature t1 = 36.0 _celsius + 42.0 _celsius ; cout << \"t1 = 36.0_celsius + 42.0_celsius\" << endl ; cout << \"t1 = \" << t1 . celsius () << \"C \" << t1 . kelvin () << \"K \" << t1 . fahrenheit () << \"F \" << endl ; Temperature t2 = 36.0 _celsius + -42.0 _celsius ; cout << \"t2 = 36.0_celsius + -42.0_celsius\" << endl ; cout << \"t2 = \" << t2 . celsius () << \"C \" << t2 . kelvin () << \"K \" << t2 . fahrenheit () << \"F \" << endl ; auto t3 = 36.0 _celsius ; cout << \"t3 = \" << t3 . celsius () << \"C \" << t3 . kelvin () << \"K \" << t3 . fahrenheit () << \"F \" << endl ; auto t4 = 36 _celsius ; cout << \"t4 = \" << t4 . celsius () << \"C \" << t4 . kelvin () << \"K \" << t4 . fahrenheit () << \"F \" << endl ; // Evidemment, ceci n'est plus possible : //Temperature t5 = 25; // error: conversion from 'int' to non-scalar type 'Temperature' requested //Temperature t5 = 25.; // error: conversion from 'double' to non-scalar type 'Temperature' requested //Temperature t5 = 36_fahrenheit; // error: unable to find numeric literal operator 'operator\"\"_fahrenheit' -> il faudrait donc surcharger operator\"\" _fahrenheit(unsigned long long valeur) return 0 ; } Range-for Introduit en C++11, la boucle Range-for ex\u00e9cute une boucle for sur une plage de valeurs, telles que tous les \u00e9l\u00e9ments d'un conteneur. Lien : range-for #include <iostream> #include <vector> using namespace std ; int main () { string str = \"Hello world!\" ; for ( char c : str ) { cout << c ; } cout << '\\n' ; std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; for ( const auto & i : v ) // acces par r\u00e9f\u00e9rence constante cout << i << ' ' ; cout << '\\n' ; for ( auto i : v ) // acces par valeur (i est de type int) cout << i << ' ' ; cout << '\\n' ; int t [] = { 0 , 1 , 2 , 3 , 4 , 5 }; for ( auto n : t ) // avec un tableau cout << n << ' ' ; cout << '\\n' ; for ( auto p : { 2 , 4 , 6 }) // avec des constantes cout << p << ' ' ; cout << '\\n' ; return 0 ; } Les expressions rationnelles La biblioth\u00e8que C++ standard prend maintenant (en C++11) en charge les expressions rationnelles ( Regular Expressions ) avec l'en-t\u00eate <regex> via une s\u00e9rie d'op\u00e9rations : regex_match : correspondance exacte avec une expression rationnelle ; regex_search : recherche correspondance avec une expression rationnelle ; regex_replace : recherche correspondance avec une expression rationnelle et la remplace ; Liens : regex Syntaxe ECMAScript #include <iostream> #include <regex> using namespace std ; int main () { string str = \"Le code postal de Sarrians est 84260 et 84000 celui d'Avignon.\" ; regex reg { R \" ( \\d{5}? ) \" }; smatch matches ; while ( regex_search ( str , matches , reg )) { for ( auto x : matches ) std :: cout << x << \" \" ; cout << endl ; //cout << matches.suffix().str() << endl; str = matches . suffix (). str (); } return 0 ; } D\u00e9l\u00e9gation du constructeur En C++03, un constructeur appartenant \u00e0 une classe ne peut pas appeler un autre constructeur de cette m\u00eame classe, ce qui peut entra\u00eener de la duplication de code lors de l'initialisation de ses attributs. En permettant au constructeur de d\u00e9l\u00e9guer la cr\u00e9ation d'une instance \u00e0 un autre constructeur, C++11 apporte donc une solution. #include <iostream> using namespace std ; class Nombre { public : Nombre ( int nombre ) : nombre ( nombre ) {} Nombre () : Nombre ( 42 ) {} int getNombre () const { return nombre ; } private : int nombre ; }; int main () { Nombre n1 ; Nombre n2 ( 2 ); cout << \"n1 = \" << n1 . getNombre () << endl ; cout << \"n2 = \" << n2 . getNombre () << endl ; return 0 ; } H\u00e9ritage des constructeurs En C++03, les constructeurs d'une classe de base ne sont pas h\u00e9rit\u00e9s par ses classes d\u00e9riv\u00e9es. C++11 permet d'h\u00e9riter explicitement des constructeurs de la classe de base gr\u00e2ce \u00e0 l'instruction using : #include <iostream> using namespace std ; class Point { public : Point ( double x , double y ) : x ( x ), y ( y ) {} Point () : x ( 0. ), y ( 0. ) {} friend ostream & operator << ( ostream & os , const Point & p ); private : double x ; double y ; }; ostream & operator << ( ostream & os , const Point & p ) { os << \"<\" << p . x << \",\" << p . y << \">\" ; return os ; } class PointCouleur : public Point { public : using Point :: Point ; //... private : unsigned int couleur ; }; int main () { PointCouleur p1 ; PointCouleur p2 ( 2 , 2 ); cout << p1 << endl ; cout << p2 << endl ; return 0 ; } Liste d'initialiseurs C++11 introduit le patron de classe std::initializer_list qui permet d'initialiser les conteneurs avec une suite de valeurs entre accolades. std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; // ou : std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 }; // ou avec une map : std :: map < string , int > m { { \"a\" , 1 }, { \"b\" , 2 }, { \"c\" , 3 }, { \"d\" , 4 }, { \"e\" , 5 }, { \"f\" , 6 } }; Lien : initializer_list #include <vector> #include <iostream> using namespace std ; template < class T > class MonVecteur { public : MonVecteur ( initializer_list < T > liste ) : v ( liste ) {} void append ( std :: initializer_list < T > liste ) { v . insert ( v . end (), liste . begin (), liste . end ()); } //private: vector < T > v ; }; int main () { MonVecteur < int > mv = { 1 , 2 , 3 , 4 , 5 }; mv . append ({ 6 , 7 , 8 }); std :: cout << \"mv : \" ; for ( auto i : mv . v ) { std :: cout << i << ' ' ; } std :: cout << '\\n' ; return 0 ; } constexpr Le mot cl\u00e9 constexpr a \u00e9t\u00e9 introduit dans C++11 et am\u00e9lior\u00e9 en C++14. constexpr d\u00e9clare un objet utilisable dans ce que la norme appelle des expressions constantes. Comme const , constexpr peut \u00eatre utilis\u00e9 sur des variables mais aussi des fonctions et des constructeurs. Lien : constexpr #include <iostream> using namespace std ; constexpr size_t getTaille () { return 10 ; } constexpr size_t getTaille ( int n ) { return 10 * n ; } int main () { constexpr float x = 42.0 ; constexpr int N = 5 ; int t1 [ N ] = { 1 , 2 , 3 , 4 , 5 }; // 5 x 4 int t2 [ getTaille ()]; // 10 x 4 int t3 [ getTaille ( 2 )]; // 2 x 10 x 4 cout << \"taille t1 = \" << sizeof ( t1 ) << \" octets\" << endl ; cout << \"taille t2 = \" << sizeof ( t2 ) << \" octets\" << endl ; cout << \"taille t3 = \" << sizeof ( t3 ) << \" octets\" << endl ; return 0 ; } Les nouveaux sp\u00e9cificateurs de classe (override, default, delete, final) Le sp\u00e9cificateur default permet de demander explicitement la g\u00e9n\u00e9ration automatique de la m\u00e9thode correspondante. On l'utilise par exemple pour le constructeur de copie, le destructeur et l'op\u00e9rateur de copie : #include <iostream> using namespace std ; struct Coordonnee { double x ; double y ; Coordonnee () : x ( 0. ), y ( 0. ) {} Coordonnee ( double x , double y ) : x ( x ), y ( y ) {} }; class Point { private : Coordonnee coordonnee ; public : // Constructeurs Point () {} Point ( double x , double y ) : coordonnee ( x , y ) {} Point ( const Point & point ) = default ; // constructeur de copie // Destructeur ~ Point () = default ; // Accesseurs et mutateurs double getX () const { return coordonnee . x ; } void setX ( double x ) { this -> coordonnee . x = x ; } double getY () const { return coordonnee . y ; } void setY ( double y ) { this -> coordonnee . y = y ; } // Surcharge Point & operator = ( const Point & point ) = default ; // copie friend ostream & operator << ( ostream & os , const Point & point ); }; ostream & operator << ( ostream & os , const Point & point ) { os << \"<\" << point . coordonnee . x << \",\" << point . coordonnee . y << \">\" ; return os ; } int main () { cout << \"Les points :\" << endl ; Point p0 , p1 ( 4 , 0.0 ), p2 ( 2.5 , 2.5 ); cout << \"p0 = \" << p0 << endl ; cout << \"p1 = \" << p1 << endl ; cout << \"p2 = \" << p2 << endl ; cout << \"Constructeur de copie : Point p3(p2)\" << endl ; Point p3 ( p2 ); cout << \"p3 = \" << p3 << endl ; cout << \"Op\u00e9rateur de copie : p0 = p3\" << endl ; p0 = p3 ; cout << \"p0 = \" << p0 << endl ; return 0 ; } Inversement, le sp\u00e9cificateur delete interdira la g\u00e9n\u00e9ration automatique de la m\u00e9thode correspondante. Utilis\u00e9 pour un constructeur de copie et l'op\u00e9rateur de copie, cela rend les objets de cette classe non copiable : class Point { private : Coordonnee coordonnee ; public : // Constructeurs Point () {} Point ( double x , double y ) : coordonnee ( x , y ) {} Point ( const Point & point ) = delete ; // constructeur de copie // Destructeur ~ Point () = default ; // Accesseurs et mutateurs double getX () const { return coordonnee . x ; } void setX ( double x ) { this -> coordonnee . x = x ; } double getY () const { return coordonnee . y ; } void setY ( double y ) { this -> coordonnee . y = y ; } // Surcharge Point & operator = ( const Point & point ) = delete ; // copie friend ostream & operator << ( ostream & os , const Point & point ); }; On obtient alors les erreurs suivantes : error: use of deleted function \u2018Point::Point(const Point&)' Point p3(p2); note: declared here Point(const Point& point) = delete; error: use of deleted function \u2018Point& Point::operator=(const Point&)' p0 = p3; note: declared here Point& operator=(const Point& point) = delete; Dans la pratique : Si un constructeur est d\u00e9clar\u00e9 explicitement, aucun constructeur par d\u00e9faut n'est automatiquement g\u00e9n\u00e9r\u00e9. Si un destructeur virtuel est d\u00e9clar\u00e9 explicitement, aucun destructeur par d\u00e9faut n'est automatiquement g\u00e9n\u00e9r\u00e9. Si un constructeur de d\u00e9placement ou un op\u00e9rateur d'assignation de d\u00e9placement est d\u00e9clar\u00e9 explicitement : Aucun constructeur de copie n'est g\u00e9n\u00e9r\u00e9 automatiquement. Aucun op\u00e9rateur d'assignation de copie n'est g\u00e9n\u00e9r\u00e9 automatiquement. Si un constructeur de copie, un op\u00e9rateur d'assignation de copie, un constructeur de d\u00e9placement, un op\u00e9rateur d'assignation de mouvement ou un destructeur est d\u00e9clar\u00e9 explicitement : Aucun constructeur de d\u00e9placement n'est g\u00e9n\u00e9r\u00e9 automatiquement. Aucun op\u00e9rateur d'assignation de d\u00e9placement n'est g\u00e9n\u00e9r\u00e9 automatiquement. De plus, la norme C++11 sp\u00e9cifie les r\u00e8gles suppl\u00e9mentaires suivantes : Si un constructeur de copie ou un destructeur est d\u00e9clar\u00e9 explicitement, la g\u00e9n\u00e9ration automatique de l'op\u00e9rateur d'assignation de copie est d\u00e9conseill\u00e9e. Si un op\u00e9rateur d'assignation de copie ou un destructeur est d\u00e9clar\u00e9 explicitement, la g\u00e9n\u00e9ration automatique du constructeur de copie est d\u00e9conseill\u00e9e. Dans une d\u00e9claration ou une d\u00e9finition de m\u00e9thode, le sp\u00e9cificateur override garantit que la fonction membre est virtuelle et remplace une m\u00e9thode virtuelle d'une classe de base. class A { public : virtual void foo (); // une m\u00e9thode virtuelle void bar (); // une m\u00e9thode \"normale\" (non virtuelle) }; class B : public A { public : void foo () const override ; // Erreur : signature diff\u00e9rente void foo () override ; // Ok : B::foo() remplace A::foo() void bar () override ; // Erreur : A::bar() n'est pas une m\u00e9thode virtuelle }; int main () { // ... return 0 ; } Remarque : override permet d'\u00e9noncer que l'on fait une surcharge et le compilateur en assurera le contr\u00f4le ! Il est donc fortement conseill\u00e9 d'utiliser syst\u00e8matiquement override . Inversement, le sp\u00e9cificateur final garantit que la m\u00e9thode est virtuelle et sp\u00e9cifie qu'elle ne peut pas \u00eatre remplac\u00e9e par des classes d\u00e9riv\u00e9es. Lorsqu'il est utilis\u00e9 dans une d\u00e9finition de classe, final sp\u00e9cifie que cette classe ne peut pas \u00eatre d\u00e9riv\u00e9e. class Base { public : virtual void foo (); // une m\u00e9thode virtuelle }; class A : public Base // A h\u00e9rite (est d\u00e9riv\u00e9e) de Base { void foo () final ; // Ok : Base::foo() est remplac\u00e9e et A::foo() ne sera pas remplac\u00e9e void bar () final ; // Erreur : A::bar() n'est pas une m\u00e9thode virtuelle }; class B final : public A // B h\u00e9rite (est d\u00e9riv\u00e9e) de A et ne sera pas d\u00e9rivable { void foo () override ; // Erreur: foo() n'est pas rempla\u00e7able car final dans A }; class C : public B // Erreur : B est final { }; int main () { // ... return 0 ; } Remarque : final permet de se prot\u00e9ger d'un remplacement non d\u00e9sir\u00e9 et le compilateur en assurera le contr\u00f4le ! Il est donc fortement conseill\u00e9 d'utiliser syst\u00e8matiquement final . R\u00e9f\u00e9rence sur rvalue Chaque expression C++ a un type et appartient \u00e0 une cat\u00e9gorie de valeur ( lvalue , rvalue , ...). Pour rappel, une lvalue ( left value ou valeur \u00e0 gauche) peut appara\u00eetre \u00e0 gauche d'un op\u00e9rateur d'affectation (un nom de variable par exemple). Une rvalue ( right value ou valeur \u00e0 droite) peut appara\u00eetre \u00e0 droite d'un op\u00e9rateur d'affectation (une expression par exemple). Maintenant, une rvalue peut \u00eatre une prvalue ( pure value ) ou xvalue ( eXpiring value ). Une prvalue est une expression dont l'\u00e9valuation : calcule une valeur qui n'est pas associ\u00e9e \u00e0 un objet ou cr\u00e9e un objet temporaire et le d\u00e9signe Une xvalue est une glvalue qui d\u00e9signe un objet dont les ressources peuvent \u00eatre r\u00e9utilis\u00e9es. Une glvalue ( generalized lvalue ) est une expression dont l'\u00e9valuation d\u00e9termine l'identit\u00e9 d'un objet. int a = 2 + 3 ; // a est une lvalue // 2 + 3 est une rvalue // l'expression 2 + 3 est \u00e9valu\u00e9e \u00e0 5 et cette valeur temporaire (et non nomm\u00e9e) est affect\u00e9e \u00e0 la lvalue a // Idem pour des objets Point p1 , p2 ; // deux objets Point Point p = p1 + p2 ; // p est une lvalue // p1 + p2 est une rvalue // l'expression p1 + p2 est \u00e9valu\u00e9e (si l'op\u00e9rateur + est surcharg\u00e9 pour la classe Point) et un nouvel objet Point est cr\u00e9\u00e9 temporairement (et non nomm\u00e9) pour \u00eatre affect\u00e9 \u00e0 l'objet p (si l'op\u00e9rateur = est surcharg\u00e9 pour la classe Point) Lien : value_category Il est possible de cr\u00e9er des r\u00e9f\u00e9rences sur des lvalue (avec l'op\u00e9rateur \u00ab & \u00bb) et en C++11 sur des rvalue (avec l'op\u00e9rateur \u00ab && \u00bb) : void foo ( int & x ) // ici x est une r\u00e9f\u00e9rence sur une lvalue (et x est une lvalue) { cout << \"foo(int x) -> \" << x << endl ; } void foo ( int && x ) // ici x est une r\u00e9f\u00e9rence sur une rvalue (et x est une lvalue) { cout << \"foo(int&& x) -> \" << x << endl ; } int main () { // Pour rappel : int a = 2 ; // a est une lvalue int & ra = a ; // ra est une r\u00e9f\u00e9rence sur la lvalue 'a' int && rvb = 42 ; // rvb est une r\u00e9f\u00e9rence sur une rvalue int b = 2 ; // b est un lvalue foo ( b ); // passage d'une lvalue foo ( 42 ); // passage d'une rvalue return 0 ; } On obtient : foo(int x) -> 2 foo(int&& x) -> 42 Les r\u00e9f\u00e9rences sur rvalue prennent en charge l'impl\u00e9mentation de la notion de d\u00e9placement (ce qui am\u00e9liorera les performances en \u00e9vitant des copies inutiles). La notion de d\u00e9placement est l'id\u00e9e de transf\u00e8rer les ressources (telles que la m\u00e9moire allou\u00e9e de mani\u00e8re dynamique) d'un objet vers un autre sans avoir \u00e0 le copier. La fonction move() La fonction std::move() retourne une r\u00e9f\u00e9rence rvalue sur l'objet pass\u00e9 en argument. Il s'agit d'une fonction de service pour utiliser la notion (ou s\u00e9mantique) de d\u00e9placement . La notion de d\u00e9placement est l'id\u00e9e de transf\u00e8rer les ressources (telles que la m\u00e9moire allou\u00e9e de mani\u00e8re dynamique) d'un objet vers un autre sans avoir \u00e0 le copier. Dans la biblioth\u00e8que standard, le d\u00e9placement implique que l'objet d\u00e9plac\u00e9 est laiss\u00e9 dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9. Ce qui signifie qu'apr\u00e8s une telle op\u00e9ration, la valeur de l'objet d\u00e9plac\u00e9 ne doit \u00eatre que d\u00e9truite ou affect\u00e9e d'une nouvelle valeur; y acc\u00e9der donnera sinon une valeur non sp\u00e9cifi\u00e9e. Donc : dans une op\u00e9ration de d\u00e9placement ( move ), l'\u00e9tat de l'objet d\u00e9plac\u00e9 devient non d\u00e9fini. Cet objet ne doit plus \u00eatre utilis\u00e9. Qu'est-ce que cela veut dire ? Si on d\u00e9place un objet p1 dans un objet p2, l'\u00e9tat de p1 n'est plus disponible car il n'est plus d\u00e9fini. Il ne faut donc plus utiliser p1 (mais p1 reste un objet valide). Seul l'objet p2 est viable. Lien : move Exemples : int a = 2 ; // a est une lvalue int && rva = std :: move ( a ); // rva est une r\u00e9f\u00e9rence sur une rvalue Point p1 ( 2.5 , 2.5 ); Point && rp1 = std :: move ( p1 ); Point p2 ( 2.5 , 2.5 ); Point p3 ( std :: move ( p2 )); void swap ( Point & a , Point & b ) { Point tmp ( std :: move ( a )); a = std :: move ( b ); b = std :: move ( tmp ); } Point p4 ( 2.5 , 2.5 ), p5 ( 1. , 1. ); swap ( p4 , p5 ); Il est possible de \"convertir\" une lvalue en r\u00e9f\u00e9rence rvalue en utilisant donc la fonction std::move() ou static_cast : foo ( static_cast < int &&> ( b )); // la lvalue 'b' est cast\u00e9e en r\u00e9f\u00e9rence rvalue foo ( move ( b )); // move() retourne une r\u00e9f\u00e9rence rvalue sur 'b' On obtient : foo(int&& x) -> 2 foo(int&& x) -> 2 D\u00e9placement (constructeur et op\u00e9rateur) Le C++11 introduit un nouveau constructeur : le constructeur de d\u00e9placement. Sa signature sera : T(T&& t) . Son objectif est de \"voler\" les ressources de l'objet pass\u00e9 en param\u00e8tre tout en le laissant dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9 (cet objet pass\u00e9 en param\u00e8tre pourra par la suite \u00eatre d\u00e9truit ou recevoir une nouvelle valeur). L'objectif du constructeur de d\u00e9placement est donc d'\u00e9viter des copies inutiles et par cons\u00e9quence d'am\u00e9liorer les performances du programme. Exemples d'appel de constructeurs : Point p1 ; // constructeur par d\u00e9faut Point p2 ( p1 ); // constructeur de copie Point p3 ( Point ()); // constructeur de d\u00e9placement : Point() instancie un objet temporaire non nomm\u00e9 pass\u00e9 par r\u00e9f\u00e9rence rvalue (inutile de le copier car il suffit de le \"d\u00e9placer\" en lui volant ses ressources) Le C++11 introduit un nouvel op\u00e9rateur d'affectation : l'op\u00e9rateur de d\u00e9placement. Sa signature sera : T& operator=(T&& t) . Son objectif est de \"voler\" les ressources de l'objet pass\u00e9 en param\u00e8tre tout en le laissant dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9 (cet objet pass\u00e9 en param\u00e8tre pourra par la suite \u00eatre d\u00e9truit ou recevoir une nouvelle valeur). L'objectif de l'op\u00e9rateur de d\u00e9placement est donc d'\u00e9viter des copies inutiles et par cons\u00e9quence d'am\u00e9liorer les performances du programme. Exemples d'appel de l'op\u00e9rateur d'affectation = : p1 = p2 ; // op\u00e9rateur d'affectation = de copie p3 = p1 + p2 ; // op\u00e9rateur d'affectation = de d\u00e9placement : (p1 + p2) g\u00e9n\u00e9re un objet temporaire non nomm\u00e9 pass\u00e9 par r\u00e9f\u00e9rence rvalue (inutile de le copier car il suffit de le \"d\u00e9placer\" en lui volant ses ressources) Le constructeur de d\u00e9placement et l'op\u00e9rateur de d\u00e9placement utilisent les r\u00e9f\u00e9rences sur rvalue . On peut leur ajouter le qualificateur noexcept s'ils ne lancent pas d'exception. Liens : move_constructor move_assignment Exemple pour une classe Point : struct Coordonnee { double x ; double y ; Coordonnee () : x ( 0. ), y ( 0. ) {} Coordonnee ( double x , double y ) : x ( x ), y ( y ) {} }; class Point { private : Coordonnee * coordonnee ; public : // Constructeurs Point () : coordonnee ( new Coordonnee ()) { } Point ( double x , double y ) : coordonnee ( new Coordonnee ( x , y )) { } Point ( const Point & point ); // copie Point ( Point && point ) noexcept ; // d\u00e9placement // Destructeur ~ Point () { if ( coordonnee ) delete coordonnee ; }; // Accesseurs et mutateurs double getX () const { return coordonnee -> x ; } void setX ( double x ) { this -> coordonnee -> x = x ; } double getY () const { return coordonnee -> y ; } void setY ( double y ) { this -> coordonnee -> y = y ; } // Surcharge Point & operator = ( const Point & point ); // copie Point & operator = ( Point && point ); // d\u00e9placement friend ostream & operator << ( ostream & os , const Point & point ); friend Point operator + ( const Point & p1 , const Point & p2 ); // Services (exemples) static void swap_v1 ( Point & a , Point & b ); static void swap_v2 ( Point & a , Point & b ); }; // Constructeur de copie Point :: Point ( const Point & point ) : coordonnee ( new Coordonnee ( point . coordonnee -> x , point . coordonnee -> y )) { } // Constructeur de d\u00e9placement (le \"vol\") Point :: Point ( Point && point ) noexcept : coordonnee ( point . coordonnee ) { point . coordonnee = nullptr ; } // Copie Point & Point :: operator = ( const Point & point ) { if ( this != & point ) { delete coordonnee ; coordonnee = new Coordonnee ( point . coordonnee -> x , point . coordonnee -> y ); } return * this ; } // D\u00e9placement Point & Point :: operator = ( Point && point ) { if ( this != & point ) { delete coordonnee ; coordonnee = point . coordonnee ; // \"vol\" point . coordonnee = nullptr ; // valide mais non sp\u00e9cifi\u00e9 } return * this ; } // Surcharge ostream & operator << ( ostream & os , const Point & point ) { os << \"<\" << point . coordonnee -> x << \",\" << point . coordonnee -> y << \">\" ; return os ; } Point operator + ( const Point & p1 , const Point & p2 ) { Point p ; p . coordonnee -> x = p1 . coordonnee -> x + p2 . coordonnee -> x ; p . coordonnee -> y = p1 . coordonnee -> y + p2 . coordonnee -> y ; return p ; } void Point :: swap_v1 ( Point & a , Point & b ) // par copie { Point tmp ( a ); // constructeur de copie a = b ; // op\u00e9rateur de copie b = tmp ; // op\u00e9rateur de copie } void Point :: swap_v2 ( Point & a , Point & b ) // par d\u00e9placement { Point tmp ( move ( a )); a = move ( b ); b = move ( tmp ); } Exemple n\u00b01 : le d\u00e9placement en action cout << \"points :\" << endl ; Point p2 , p3 ( 1. , 1. ), p4 ( 2.5 , 2.5 ); cout << \"p2 = \" << p2 << endl ; cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; cout << \"p2 = p3 + p4\" << endl ; p2 = p3 + p4 ; // move cout << \"p2 = \" << p2 << endl ; cout << endl ; cout << \"p5 <- p2\" << endl ; Point p5 ( move ( p2 )); // move cout << \"p5 = \" << p5 << endl ; cout << endl ; cout << \"p3 <-> p4\" << endl ; Point :: swap_v1 ( p3 , p4 ); // par copie cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; cout << \"p3 <-> p4\" << endl ; Point :: swap_v2 ( p3 , p4 ); // move cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; On obtient : points : default Point 0x7ffc389b1908 Point 0x7ffc389b1910 Point 0x7ffc389b1918 p2 = <0,0> p3 = <1,1> p4 = <2.5,2.5> p2 = p3 + p4 default Point 0x7ffc389b1920 move operator= 0x7ffc389b1908 p2 = <3.5,3.5> p5 <- p2 move Point 0x7ffc389b1920 p5 = <3.5,3.5> p3 <-> p4 copy Point 0x7ffc389b18c0 copy operator= 0x7ffc389b1910 copy operator= 0x7ffc389b1918 p3 = <2.5,2.5> p4 = <1,1> p3 <-> p4 move Point 0x7ffc389b18c0 move operator= 0x7ffc389b1910 move operator= 0x7ffc389b1918 p3 = <1,1> p4 = <2.5,2.5> Exemple n\u00b02 : am\u00e9lioration des performances auto start = std :: chrono :: high_resolution_clock :: now (); // d\u00e9marrage chronom\u00e8tre vector < Point > points ; for ( int i = 0 ; i < 1000000 ; ++ i ) { points . push_back ( Point ( i , i * 2 )); } //vector<Point> courbe(points); // test 1 : par copie vector < Point > courbe ( move ( points )); // test 2 : par d\u00e9placement reverse ( courbe . begin (), courbe . end ()); // pour s'amuser ;) auto end = chrono :: high_resolution_clock :: now (); // arr\u00eat chronom\u00e8tre chrono :: duration < double > elapsed = end - start ; // calcul du temps // Affichage des r\u00e9sultats cout << \"Duration : \" << elapsed . count () << \" s \\n \" ; cout << \"Constructions : \" << Point :: constructions << \" \\n \" ; cout << \"Copies : \" << Point :: copies << \" \\n \" ; cout << \"Deplacements : \" << Point :: deplacements << \" \\n \" ; cout << \"Total : \" << ( Point :: constructions + Point :: deplacements ) << \" \\n \" ; On obtient : par copie : Duration : 0.193734 s Constructions : 4548575 Copies : 1000000 Deplacements : 0 Total : 4548575 par d\u00e9placement : Duration : 0.0961808 s Constructions : 1000000 Copies : 0 Deplacements : 3548575 Total : 4548575 Threads C++11 fournit une classe pour repr\u00e9senter les threads d'ex\u00e9cution individuels. Un thread est un fil d'ex\u00e9cution (une s\u00e9quence d'instructions) qui peut \u00eatre ex\u00e9cut\u00e9 simultan\u00e9ment avec d'autres fils de ce type dans des environnements multithreading , tout en partageant un m\u00eame espace d'adressage. Un objet thread initialis\u00e9 repr\u00e9sente un thread d'ex\u00e9cution actif. Un tel objet thread est joignable et poss\u00e8de un identifiant de thread unique. Lien : thread Exemple avec un thread : #include <iostream> #include <thread> // $ g++ thread.cpp -lpthread using namespace std ; void unThread () { cout << \"Hello !\" << endl ; } int main () { thread hello ( unThread ); // cr\u00e9ation et lancement du thread hello . join (); // attendre la fin du thread return 0 ; } Exemple avec deux threads : #include <iostream> #include <thread> #include <chrono> // $ g++ thread-2.cpp -lpthread using namespace std ; void etoile () { for ( int i = 0 ; i < 10 ; ++ i ) { this_thread :: sleep_for ( chrono :: duration < int , milli > ( 250 )); cout << \"*\" ; } } void diese () { for ( int i = 0 ; i < 10 ; ++ i ) { this_thread :: sleep_for ( chrono :: duration < int , milli > ( 250 )); cout << \"#\" ; } } int main () { setbuf ( stdout , NULL ); thread t1 ( etoile ); // cr\u00e9ation et lancement du thread thread t2 ( diese ); // cr\u00e9ation et lancement du thread t1 . join (); // attendre la fin du thread t2 . join (); // attendre la fin du thread cout << endl ; return 0 ; } Voir aussi : call_once atomic std::future et std::async std::future est un objet qui peut r\u00e9cup\u00e9rer une valeur de mani\u00e8re synchronis\u00e9e. std::async permet d'appeler une fonction de mani\u00e8re asynchrone (sans attendre la fin de l'ex\u00e9cution de la fonction). La valeur retourn\u00e9e par la fonction sera accessible via l'objet future retourn\u00e9 lors de l'appel et en appelant sa m\u00e9thode get() . Liens : future async #include <iostream> #include <future> // pour async et future #include <chrono> // $ g++ future.cpp -lpthread using namespace std ; // la factorielle d'un entier naturel n est le produit des nombres entiers strictement positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 n long factorielle ( long n ) { return n > 1 ? ( n * factorielle ( n -1 )) : 1 ; // https://fr.wikipedia.org/wiki/Factorielle#Algorithme } // exemple : http://www.cplusplus.com/reference/future/future/ bool is_prime ( int x ) { // version non optimis\u00e9e for ( int i = 2 ; i < x ; ++ i ) { if ( x % i == 0 ) return false ; } return true ; } int main () { // future permet de lancer une fonction de mani\u00e8re asynchrone et // d'en r\u00e9cup\u00e9rer le r\u00e9sultat long n = 15 ; future < long > resultat1 = async ( factorielle , n ); cout << \"veuillez patienter pendant le calcul de la factorielle de \" << n ; chrono :: milliseconds tempo ( 100 ); while ( resultat1 . wait_for ( tempo ) == future_status :: timeout ) cout << '.' << flush ; cout << '\\n' ; cout << \"r\u00e9sultat : \" << resultat1 . get () << \" \\n \" ; future < bool > resultat2 = async ( is_prime , 444444443 ); cout << \"veuillez patienter pendant la v\u00e9rification\" ; while ( resultat2 . wait_for ( tempo ) == future_status :: timeout ) cout << '.' << flush ; cout << '\\n' ; cout << \"444444443 \" << ( resultat2 . get () ? \"est\" : \"n'est pas\" ) << \" premier. \\n \" ; return 0 ; } Mutex Un mutex est un objet verrouillable con\u00e7u pour prot\u00e9ger les acc\u00e8s aux sections critiques de code en emp\u00eachant d'autres threads de s'ex\u00e9cuter simultan\u00e9ment et d'acc\u00e9der aux m\u00eames emplacements m\u00e9moire. Lien : mutex #include <iostream> #include <thread> #include <mutex> // Chaque thread (tache) va faire ses COUNT boucles #define COUNT 5000 //#define MUTEX // avec ou sans mutex using namespace std ; int value_globale = 1 ; #ifdef MUTEX mutex m ; #endif // Avec mutex : g++ mutex.cpp -DMUTEX -lpthread // Sans mutex : g++ mutex.cpp -lpthread void increment () { int value = 0 ; for ( int i = 0 ; i < COUNT ; ++ i ) { #ifdef MUTEX m . lock (); #endif // R\u00e9cup\u00e8re la value value = value_globale ; // Incr\u00e9mente la value value += 1 ; // Stocke la value value_globale = value ; #ifdef MUTEX m . unlock (); #endif } } void decrement () { int value = 0 ; for ( int i = 0 ; i < COUNT ; ++ i ) { #ifdef MUTEX m . lock (); #endif // R\u00e9cup\u00e8re la value value = value_globale ; // D\u00e9cr\u00e9mente la value value -= 1 ; // Stocke la value value_globale = value ; #ifdef MUTEX m . unlock (); #endif } } int main () { setbuf ( stdout , NULL ); cout << \"Avant l'ex\u00e9cution des threads : value = \" << value_globale << \" (\" << COUNT << \" boucles) \\n \" ; thread t1 ( increment ); // cr\u00e9ation et lancement du thread thread t2 ( decrement ); // cr\u00e9ation et lancement du thread t1 . join (); // attendre la fin du thread t2 . join (); // attendre la fin du thread cout << \" \\n Apres l'ex\u00e9cution des threads : value = \" << value_globale << \" (\" << COUNT << \" boucles) \\n \" ; return 0 ; } Voir aussi : lock_guard lock_guard est un objet qui g\u00e8re un mutex en le gardant toujours verrouill\u00e9. mutex m ; void foo () { lock_guard < mutex > lock ( m ); // cr\u00e9ation et appel \u00e0 lock() // section critique ... } // destruction et appel \u00e0 unlock() Voir aussi : condition_variable std::ref La fonction std::ref (dans <functional> ) retourne un objet de type std::reference_wrapper<T> qui est en fait une r\u00e9f\u00e9rence sur l'\u00e9l\u00e9ment. Lien : std::ref #include <iostream> #include <functional> #include <thread> using namespace std ; // $ g++ ref.cpp -lpthread void foo ( int & data ) { data = 42 ; } int main () { int i1 = 100 ; cout << \"i1 = \" << i1 << endl ; foo ( std :: ref ( i1 )); cout << \"i1 = \" << i1 << endl ; i1 = 100 ; cout << \"i1 = \" << i1 << endl ; //std::thread t1(foo, i1); // no works std :: thread t1 ( foo , std :: ref ( i1 )); // works t1 . join (); cout << \"i1 = \" << i1 << endl ; return 0 ; } Les tableaux \u00e0 taille fixe array C++11 fournit le nouveau type de tableau std::array en tant que conteneur standard (d\u00e9fini dans l'en-t\u00eate <array> ). Contrairement aux autres conteneurs standards, les tableaux array ont une taille fixe. array fonctionne de la m\u00eame mani\u00e8re que les tableaux en C sauf qu'il permet d'\u00eatre copi\u00e9 (op\u00e9ration relativement co\u00fbteuse car c'est une copie de la totalit\u00e9 du bloc de m\u00e9moire) et peut s'utiliser explicitement en pointeur. Lien : array #include <iostream> #include <array> #define TAILLE 3 using namespace std ; int main () { // En C/C++ cout << \"-> En C/C++\" << endl ; int t1 [ TAILLE ] = { 10 , 20 , 30 }; cout << \"Elements du tableau t1 (avant) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t1 [ i ] << \" \" ; cout << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) ++ t1 [ i ]; cout << \"Elements du tableau t1 (apr\u00e8s) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t1 [ i ] << \" \" ; cout << endl ; cout << \"Elements du tableau t1 (apr\u00e8s) : \" << endl ; for ( int element : t1 ) cout << element << \" \" ; cout << endl ; cout << endl ; // En C++11 cout << \"-> En C++11\" << endl ; array < int , TAILLE > t2 { 10 , 20 , 30 }; cout << \"Elements du tableau t2 (avant) : \" << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) cout << t2 [ i ] << \" \" ; cout << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) ++ t2 [ i ]; cout << \"Elements du tableau t2 (apr\u00e8s) : \" << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) cout << t2 [ i ] << \" \" ; cout << endl ; cout << \"Elements du tableau t2 (apr\u00e8s) : \" << endl ; for ( int element : t2 ) cout << element << \" \" ; cout << endl ; // Avec un pointeur int * t3 = t2 . data (); // data() renvoie un pointeur vers le premier \u00e9l\u00e9ment du tableau // Dans array, les \u00e9l\u00e9ments du tableau sont stock\u00e9s dans des emplacements m\u00e9moire contigus, // le pointeur r\u00e9cup\u00e9r\u00e9 (ici t3) peut \u00eatre utilis\u00e9 pour acc\u00e9der \u00e0 n'importe quel \u00e9l\u00e9ment du tableau cout << \"Elements du tableau t2 (avec un pointeur) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t3 [ i ] << \" \" ; // cout << *(t3+i) << \" \"; cout << endl ; // Avec un it\u00e9rateur cout << \"Elements du tableau t2 (avec un it\u00e9rateur) : \" << endl ; //for(array<int,TAILLE>::iterator it = t2.begin(); it != t2.end(); ++it) for ( auto it = t2 . begin (); it != t2 . end (); ++ it ) cout << * it << \" \" ; cout << endl ; return 0 ; } Les listes simplement cha\u00een\u00e9e forward_list est l'impl\u00e9mentation d'une liste simplement cha\u00een\u00e9e accessible seulement par sa t\u00eate ( front ). Lien : http://www.cplusplus.com/reference/forward_list/forward_list/[forward_list] #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > liste = { 10 , 20 , 30 , 40 , 50 }; cout << \"liste : \\n \" ; for ( int & element : liste ) cout << element << \" \" ; cout << '\\n' ; return 0 ; } Le type Tuple Un tuple est une collection de dimension fixe d'objets de types diff\u00e9rents. Tout type d'objet peut \u00eatre \u00e9l\u00e9ment d'un tuple. Cette nouvelle fonctionnalit\u00e9 est impl\u00e9ment\u00e9e dans le nouvel en-t\u00eate <tuple> et b\u00e9n\u00e9ficie des extensions de C++11. Lien : tuple #include <iostream> #include <tuple> // cf. http://www.cplusplus.com/reference/tuple/tuple/ using namespace std ; int main () { typedef tuple < string , string , int , double > tuple_1 ; tuple_1 foo ( \"John\" , \"Smith\" , 50 , 1.87 ); cout << get < 0 > ( foo ) << \" \" << get < 1 > ( foo ) << endl ; cout << \"Nb elements du tuple : \" << tuple_size < tuple_1 >:: value << endl ; tuple < double , double , char > p1 ( 0. , 0. , 'A' ); cout << get < 2 > ( p1 ) << \" : \" << get < 0 > ( p1 ) << \",\" << get < 1 > ( p1 ) << endl ; get < 2 > ( p1 ) = 'B' ; cout << get < 2 > ( p1 ) << \" : \" << get < 0 > ( p1 ) << \",\" << get < 1 > ( p1 ) << endl ; auto bar = std :: make_tuple ( \"pi\" , 3.14 ); cout << get < 0 > ( bar ) << \" = \" << get < 1 > ( bar ) << endl ; return 0 ; } Tables de hachage Une table de hachage ( hash table ) est une structure de donn\u00e9es qui permet une association cl\u00e9-\u00e9l\u00e9ment. Il s'agit d'un tableau ne comportant pas d'ordre (contrairement \u00e0 un tableau ordinaire qui est index\u00e9 par des entiers). On acc\u00e8de \u00e0 chaque \u00e9l\u00e9ment de la table par sa cl\u00e9. L'acc\u00e8s s'effectue par une fonction de hachage qui transforme une cl\u00e9 en une valeur de hachage (un nombre) indexant les \u00e9l\u00e9ments de la table. Pour \u00e9viter les conflits de noms avec les biblioth\u00e8ques non standards qui ont leur propre impl\u00e9mentation des tables de hachage, on utilisera le pr\u00e9fixe unordered au lieu de hash . Il existe deux types de tables de hachage dans la STL : hash_set<K> : table de hachage simple, stocke seulement des cl\u00e9s de type K. hash_map<K,T> : table de hachage double, stocke des cl\u00e9s de type K associ\u00e9es \u00e0 des valeurs de type T. \u00c0 une cl\u00e9 donn\u00e9e ne peut \u00eatre stock\u00e9e qu'une seule valeur. Liens : hash_set hash_map Remarque : hash_set et hash_map font partie de la STL mais ne sont pas int\u00e9gr\u00e9s \u00e0 la biblioth\u00e8que standard C++. Les compilateurs GNU C++ et Visual C++ de Microsoft les ont quand m\u00eame impl\u00e9ment\u00e9s. Le standard C++11 propose des conteneurs similaires : unordered_set et unordered_map . Liens : unordered_set unordered_map #include <iostream> #include <string> #include <unordered_map> using namespace std ; int main () { unordered_map < string , string > hashtable ; //hashtable.emplace(\"www.wikipedia.fr\", \"78.109.84.114\"); //cout << \"Adresse IP : \" << hashtable[\"www.wikipedia.fr\"] << endl; hashtable . insert ( make_pair ( \"www.cplusplus.com\" , \"167.114.170.15\" )); hashtable . insert ( make_pair ( \"www.google.fr\" , \"216.58.204.67\" )); cout << \"Adresse IP de www.google.fr : \" << hashtable [ \"www.google.fr\" ] << endl << endl ; cout << \"La table : \" << endl ; for ( auto itr = hashtable . begin (); itr != hashtable . end (); itr ++ ) { cout << ( * itr ). first << \" -> \" << ( * itr ). second << endl ; } return 0 ; } On peut cr\u00e9er sa propre fonction de hachage avec un foncteur ( Function Object ) est un objet qui se comporte comme une fonction en surchargeant l'op\u00e9rateur () : #include <iostream> #include <string> #include <unordered_map> using namespace std ; // Foncteur de hachage class Hachage { public : size_t operator ()( const string & s ) const { cout << \"[hash : \" << hash < string > ()( s ) << \"]\" << endl ; return hash < string > ()( s ); } }; int main () { unordered_map < string , string , Hachage > hashtable ; hashtable . insert ( make_pair ( \"www.wikipedia.fr\" , \"78.109.84.114\" )); hashtable . insert ( make_pair ( \"www.cplusplus.com\" , \"167.114.170.15\" )); hashtable . insert ( make_pair ( \"www.google.fr\" , \"216.58.204.67\" )); cout << endl << \"La table : \" << endl ; for ( auto itr = hashtable . begin (); itr != hashtable . end (); itr ++ ) { cout << ( * itr ). first << \" -> \" << ( * itr ). second << endl ; } cout << endl ; cout << \"Adresse IP de www.google.fr : \" << hashtable [ \"www.google.fr\" ] << endl ; return 0 ; } On peut utiliser unordered_map avec ses propres classes \u00e0 condition de d\u00e9finir l'op\u00e9rateur == : #include <iostream> #include <string> #include <unordered_map> using namespace std ; class Fabricant { private : string nom ; public : Fabricant ( string nom ) { this -> nom = nom ; } string getNom () const { return nom ; } bool operator == ( const Fabricant & f ) const { return nom == f . nom ; } }; class Modele { private : string nom ; int annee ; public : Modele ( string nom , int annee ) { this -> nom = nom ; this -> annee = annee ; } string getNom () const { return nom ; } int getAnnee () const { return annee ; } bool operator == ( const Modele & m ) const { return ( nom == m . nom && annee == m . annee ); } }; class Hachage { public : size_t operator ()( const Modele & m ) const { return hash < string > ()( m . getNom ()) ^ hash < int > ()( m . getAnnee ()); } }; int main () { unordered_map < Modele , Fabricant , Hachage > catalogue ; Modele zoe ( \"Zoe\" , 2012 ); Modele megane3 ( \"Megane III\" , 2008 ); Modele clio3 ( \"Clio III\" , 2005 ); Modele bipper ( \"Bipper\" , 2007 ); Fabricant renault ( \"Renault\" ); Fabricant peugeot ( \"Peugeot\" ); catalogue . insert ( make_pair ( zoe , renault )); catalogue . insert ( make_pair ( megane3 , renault )); catalogue . insert ( make_pair ( clio3 , renault )); catalogue . insert ( make_pair ( bipper , peugeot )); for ( auto & itr : catalogue ) { cout << itr . second . getNom () << \" \" << itr . first . getNom () << \" \" << itr . first . getAnnee () << endl ; } return 0 ; } Nombres pseudo-al\u00e9atoires La biblioth\u00e8que standard du C permet de g\u00e9n\u00e9rer des nombres pseudo-al\u00e9atoires gr\u00e2ce \u00e0 la fonction rand() . C++11 va fournir une mani\u00e8re diff\u00e9rente de g\u00e9n\u00e9rer les nombres pseudo-al\u00e9atoires : un moteur de g\u00e9n\u00e9ration, qui contient l'\u00e9tat du g\u00e9n\u00e9rateur et produit les nombres pseudo-al\u00e9atoires ; une distribution, qui d\u00e9termine les valeurs que le r\u00e9sultat peut prendre ainsi que sa loi de probabilit\u00e9. C++11 d\u00e9finit trois algorithmes de g\u00e9n\u00e9ration (linear_congruential, subtract with carry et mersenne_twister), chacun ayant des avantages et des inconv\u00e9nients et fournira un certain nombre de lois standard (uniform_int_distribution, bernoulli_distribution, ...). Lien : random #include <iostream> #include <random> #include <functional> // std::bind #include <chrono> using namespace std ; int main () { unsigned seed = std :: chrono :: system_clock :: now (). time_since_epoch (). count (); std :: uniform_int_distribution < int > distribution1 ( 1 , 6 ); // un d\u00e9 \u00e0 6 faces std :: default_random_engine default_engine ( seed ); int de = distribution1 ( default_engine ); // genere un nombre entre 1 et 6 cout << \"de = \" << de << '\\n' ; std :: uniform_int_distribution < int > distribution2 ( 0 , 99 ); std :: mt19937 engine ( seed ); auto generator = std :: bind ( distribution2 , engine ); int random = generator (); // genere un nombre entre 0 et 99 cout << \"random = \" << random << '\\n' ; return 0 ; } Fonction lambda Une lambda est une fonction possiblement anonyme et destin\u00e9e \u00e0 \u00eatre utilis\u00e9e localement. Liens : lambda Des fonctions somme toute lambdas Syntaxe : [zone de capture](param\u00e8tres de la lambda) -> type de retour { instructions } Exemple simpliste : int main () { []() -> void {}; return 0 ; } Exemples basiques : #include <algorithm> #include <iostream> #include <string> #include <vector> using namespace std ; int main () { // Exemple 1 auto lambda = []( string const & message ) -> void { cout << \"Message re\u00e7u : \" << message << endl ; }; lambda ( \"Hello !\" ); // Exemple 2 vector < string > const chaines { \"Un mot\" , \"Autre chose\" , \"Du blabla\" , \"Du texe\" , \"Des lettres\" }; for_each ( begin ( chaines ), end ( chaines ), []( string const & message ) -> void { cout << \"Message re\u00e7u : \" << message << endl ; }); return 0 ; } Les expressions Lambda (ou closure ) sont donc un bon moyen de passer du code en param\u00e8tre d'une fonction : // Exemple 3 vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; cout << \"v : \" ; for ( auto i : v ) // i est un int { cout << i << ' ' ; } cout << '\\n' ; unsigned int nbElementsPairs = 0 ; nbElementsPairs = count_if ( v . begin (), v . end (), []( auto x ) { return ! ( x % 2 ); }); cout << \"nbElementsPairs : \" << nbElementsPairs << endl ; Lien : count_if Remarque : Cette utilisation est simple et place le code du pr\u00e9dicat au bon endroit (sans avoir besoin de d\u00e9clarer une fonction pour cela). Les lambdas peuvent acc\u00e9der aux variables dans la port\u00e9e par r\u00e9f\u00e9rence ou par valeur : // Exemple 4 int borneMax = 5 ; unsigned int nbElements = 0 ; // acc\u00e8s aux variables par r\u00e9f\u00e9rence [&] nbElements = count_if ( v . begin (), v . end (), [ & ]( auto x ) { return ( x <= borneMax ); }); cout << \"nbElements : \" << nbElements << endl ; borneMax = 4 ; // acc\u00e8s aux variables par copie [=] nbElements = count_if ( v . begin (), v . end (), [ = ]( auto x ) { return ( x <= borneMax ); }); cout << \"nbElements : \" << nbElements << endl ; std::function et std::mem_fn Le template std::function permet d'encapsuler un pointeur de fonction ou une lambda : #include <iostream> #include <string> #include <functional> using namespace std ; void foo ( string str ) { cout << \"message : \" << str << endl ; } int main () { std :: function < void ( string ) > fn_foo = foo ; fn_foo ( \"Hello world!\" ); return 0 ; } Le template std::mem_fn permet d'encapsuler un pointeur de m\u00e9thode (fonction membre) d'une classe : #include <iostream> #include <string> #include <functional> using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} void print ( int n = 1 ) const { for ( int i = 0 ; i < n ; ++ i ) cout << str << '\\n' ; } private : string str ; }; int main () { const Foo foo ( \"Hello world!\" ); auto fn1 = mem_fn ( & Foo :: print ); fn1 ( foo , 5 ); return 0 ; } Liens : std::function std::mem_fn C++14 Lien : C++14 Nombres binaires Avec le C++14, il est d\u00e9sormais possible de sp\u00e9cifier des nombres binaires en utilisant le pr\u00e9fixe 0b ou 0B : #include <iostream> using namespace std ; int main () { int i = 0b01010101 ; int j = 0B10101010 ; cout << \"i = \" << i << \" (0x\" << hex << i << \")\" << endl ; cout << \"j = \" << j << \" (0x\" << hex << j << \")\" << endl ; return 0 ; } S\u00e9parateur de chiffres Pour am\u00e9liorer la lisibilit\u00e9 : #include <iostream> using namespace std ; int main () { int i = 0b0101'0101 ; int j = 0b1010'1010 ; cout << \"i = \" << i << \" (0x\" << hex << i << \")\" << endl ; cout << \"j = \" << j << \" (0x\" << hex << j << \")\" << endl ; int un_milliard = 1'000'000'000 ; return 0 ; } C++17 Liens : De C++14 \u00e0 C++17 C++17 C++17 (en) Le type byte En C++17, std::byte (dans <cstddef> ) repr\u00e9sente un octet en m\u00e9moire. En C/C++, on utilisait le type char ou unsigned char . Attention, std::byte n'est pas un type caract\u00e8re et ni un type arithm\u00e9tique. Seuls op\u00e9rateurs au niveau du bit ont \u00e9t\u00e9 surcharg\u00e9s : les op\u00e9rateurs de d\u00e9calage comme << , >> , <<= , >>= les op\u00e9rateurs logiques comme | , & , ^ , ~ , |= , &= , ^= Le type byte n'est pas directement utilisable comme un entier sauf via la fonction std::to_integer<>() . Lien : std::byte #include <iostream> #include <cstddef> using namespace std ; // g++ -std=c++17 byte.cpp int main () { byte b1 { 10 }; byte b2 { 21 }; cout << \"b1 = \" << to_integer < int > ( b1 ) << endl ; b2 <<= 1 ; cout << \"b2 = \" << to_integer < int > ( b2 ) << endl ; byte b3 = b1 & b2 ; cout << \"b3 = b1 & b2\" << endl ; cout << \"b3 = \" << to_integer < int > ( b3 ) << endl ; int i1 = to_integer < int > ( b3 ); cout << \"i1 = \" << i1 << endl ; return 0 ; } std::invoke En C++17, la fonction std::invoke (dans <functional> ) permet d'appeler une fonction ou une m\u00e9thode en lui passant des arguments. Lien : std::invoke #include <iostream> #include <string> #include <functional> //$ g++ -std=c++17 invoke.cpp using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} void print ( int n = 1 ) const { for ( int i = 0 ; i < n ; ++ i ) cout << str << '\\n' ; } private : string str ; }; void print ( string str ) { cout << \"message : \" << str << endl ; } int main () { // fonction invoke ( print , \"Hello world!\" ); const Foo foo ( \"Hello world!\" ); // m\u00e9thode invoke ( & Foo :: print , foo , 2 ); return 0 ; } std::optional En C++17, le type std::optional<T> peut contenir une valeur ou pas. On utilise la m\u00e9thode has_value() pour d\u00e9terminer s'il y a une valeur dans l'objet et value() pour la r\u00e9cup\u00e9rer. Lien : std::optional #include <iostream> #include <string> #include <optional> // $ g++ -std=c++17 optional.cpp using namespace std ; class Article { public : Article ( const string & libelle ) : libelle ( libelle ) {} Article ( const string & libelle , optional < double > prix ) : libelle ( libelle ), prix ( prix ) {} string getLibelle () const { return libelle ; } optional < double > getPrix () const { if ( prix . has_value ()) return prix ; else return {}; } private : string libelle ; optional < double > prix ; }; int main () { Article article1 ( \"De'Longhi Magnifica S\" , 295.0 ); Article article2 ( \"Philips EP2220\" ); cout << \"Article \" << article1 . getLibelle () << endl ; auto prix1 = article1 . getPrix (); if ( prix1 . has_value ()) { cout << \" prix : \" << prix1 . value () << \" euros\" << endl ; } else { cout << \" pas de prix pour cet article\" << endl ; } cout << \"Article \" << article2 . getLibelle () << endl ; auto prix2 = article2 . getPrix (); if ( prix2 . has_value ()) { cout << \" prix : \" << prix2 . value () << \" euros\" << endl ; } else { cout << \" pas de prix pour cet article\" << endl ; } return 0 ; } std::any En C++17, le type std::any peut contenir n'importe quel type ou aucune valeur. C'est l'\u00e9quivalent d'un void * type-safe . On peut utiliser la m\u00e9thode has_value() pour d\u00e9terminer s'il y a une valeur. Il existe aussi any_cast<T>() pour r\u00e9aliser des conversions vers des types T . type() retourne une r\u00e9f\u00e9rence sur le type type_info . Lien : std::any #include <iostream> #include <string> #include <any> // $ g++ -std=c++17 any.cpp using namespace std ; int main () { any a = 1 ; cout << a . type (). name () << \" -> \" << any_cast < int > ( a ) << '\\n' ; any s = string ( \"Hello world!\" ); cout << s . type (). name () << \" -> \" << any_cast < string > ( s ) << '\\n' ; return 0 ; } C++20 Liens : C++20 C++20 (en) Wikip\u00e9dia C++11 C++14 C++17 C++20 Voir aussi C++ - Sujets divers","title":"C++ moderne"},{"location":"#c-moderne","text":"Ce document en PDF : c++-moderne.pdf","title":"C++ moderne"},{"location":"#c","text":"C++ est un langage de programmation compil\u00e9 permettant la programmation sous de multiples paradigmes (comme la programmation proc\u00e9durale, orient\u00e9e objet ou g\u00e9n\u00e9rique). Ses bonnes performances, et sa compatibilit\u00e9 avec le C en font un des langages de programmation les plus utilis\u00e9s dans les applications o\u00f9 la performance est critique. Cr\u00e9\u00e9 initialement par Bjarne Stroustrup dans les ann\u00e9es 1980, le langage C++ est aujourd'hui normalis\u00e9 par l'ISO. Sa premi\u00e8re normalisation date de 1998 (ISO/CEI 14882:1998), ensuite amend\u00e9e par l'erratum technique de 2003 (ISO/CEI 14882:2003). Une importante mise \u00e0 jour a \u00e9t\u00e9 ratifi\u00e9e et publi\u00e9e par l'ISO en septembre 2011 sous le nom de ISO/IEC 14882:2011, ou C++11 . Depuis, des mises \u00e0 jour sont publi\u00e9es r\u00e9guli\u00e8rement : en 2014 (ISO/CEI 14882:2014 ou C++14 ) puis en 2017 (ISO/CEI 14882:2017 ou C++17 ). [source : wikipedia.org ] Les changements du langage C++ concernent aussi bien le langage initial que la biblioth\u00e8que standard. Remarque : La biblioth\u00e8que standard du C++ ( C++ Standard Library ) est une biblioth\u00e8que de classes et de fonctions standardis\u00e9es selon la norme ISO pour le langage C++. Elle contient aussi la biblioth\u00e8que standard du C. Une des principales briques de la biblioth\u00e8que standard du C++ est sans aucun doute la STL ( Standard Template Library ), \u00e0 tel point qu'il y a souvent confusion entre les deux. Dans l'index de popularit\u00e9 des langages TIOBE , le C repr\u00e9sente 16,2 % (premi\u00e8re place) et le C++ 7,6 % (quatri\u00e8me place) en novembre 2020. Liens : www.cplusplus.com Comit\u00e9 du standard C++","title":"C++"},{"location":"#c-moderne_1","text":"Le C++ moderne est apparu avec la mise \u00e0 jour C++11. Les standards C++11, 14, 17 et bient\u00f4t 20 apportent de nombreuses fonctionnalit\u00e9s : gestion automatique de la m\u00e9moire via des pointeurs intelligents ( Smart Pointers ), d\u00e9duction de type automatique \u00e0 la d\u00e9claration via auto , etc ... L'impl\u00e9mentation des standards C++ va d\u00e9pendre du compilateur utilis\u00e9, de sa version et des options invoqu\u00e9es. Exemple sous Ubuntu 18.04 : $ g++ --version g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 $ man g++ ... g++ [-std=standard] ... ... -std= Determine the language standard. This option is currently only supported when compiling C or C++. ... c11 c1x iso9899:2011 ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name c1x is deprecated. c++11 c++0x The 2011 ISO C++ standard plus amendments. The name c++0x is deprecated. c++14 c++1y The 2014 ISO C++ standard plus amendments. The name c++1y is deprecated. gnu++14 gnu++1y GNU dialect of -std=c++14. This is the default for C++ code. The name gnu++1y is deprecated. c++1z The next revision of the ISO C++ standard, tentatively planned for 2017. Support is highly experimental, and will almost certainly change in incompatible ways in future releases. Remarque : il est possible de d\u00e9finir le standard utilis\u00e9 pour le compilateur C++ dans un projet Qt . Pour cela, il suffit de l'indiquer dans la variable CONFIG de son fichier .pro : CONFIG += c++11","title":"C++ moderne"},{"location":"#les-exemples","text":"https://github.com/tvaira/cpp-moderne","title":"Les exemples"},{"location":"#c11","text":"Lien : C++11","title":"C++11"},{"location":"#les-types-et-les-variables","text":"Le langage C++ est dit fortement typ\u00e9. Chaque variable poss\u00e8de un type. Une d\u00e9finition est compos\u00e9e de : un type pour d\u00e9finir la convention d'interpr\u00e9tation des valeurs possibles un objet qui contient en m\u00e9moire la valeur d'un type une valeur une variable qui est le nom de l'objet Chaque type est directement li\u00e9 \u00e0 une architecture mat\u00e9rielle et poss\u00e8de une taille fixe. La taille d'un objet et/ou d'un type est obtenue avec l'op\u00e9rateur sizeof . L'op\u00e9rateur typeid() (dans type_info ) permet lui d'obtenir le type d'une valeur \u00e0 l'ex\u00e9cution : #include <iostream> #include <string> #include <typeinfo> using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} private : string str ; }; int main () { int i = 10 ; int * pi = & i ; string s = \"hello\" ; cout << \"i : \" << typeid ( i ). name () << '\\n' ; cout << \"&i : \" << typeid ( & i ). name () << '\\n' ; cout << \"pi : \" << typeid ( pi ). name () << '\\n' ; cout << \"*pi : \" << typeid ( * pi ). name () << '\\n' ; cout << \"s : \" << typeid ( s ). name () << '\\n' ; auto booleen = false ; // bool auto f = 1.5 ; // double cout << \"booleen : \" << typeid ( booleen ). name () << '\\n' ; cout << \"f : \" << typeid ( f ). name () << '\\n' ; Foo foo ( s ); cout << \"foo : \" << typeid ( foo ). name () << '\\n' ; return 0 ; } Remarque : Il existe un moyen d'ins\u00e9rer des cha\u00eenes de caract\u00e8res complexes dans le code source sans le formatter avec R\"(raw_string)\" . Ceci est pratique avec des cha\u00eenes qui contiennent des guillemets \" et/ou des antislash \\ . Lien : string_literal #include <iostream> using namespace std ; int main () { string str1 = \"<a href= \\\" file \\\" >C: \\\\ Program Files \\\\ </a>\" ; // avant string str2 = R \" ( <a href=\"file\">C:\\Program Files\\</a> ) \" ; // C++11 cout << \"str1 = \" << str1 << endl ; cout << \"str2 = \" << str2 << endl ; return 0 ; }","title":"Les types et\u00a0les\u00a0variables"},{"location":"#initialisation","text":"Avant d'\u00eatre utilis\u00e9, un objet doit \u00eatre initialis\u00e9. Il existe l'op\u00e9rateur = , les crochets {} ou les parenth\u00e8ses () comme initialiseurs universels : int a = 10 ; int b ( 20 ); int t [ 3 ] = { 1 , 2 , 3 }; Remarque : Le nouveau standard ISO a introduit une syntaxe d'initialisation uniforme avec les accolades {} . int a { 10 }; int b { 20 }; int t [ 3 ] { 1 , 2 , 3 }; std :: vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; En C++03, il est possible d'assigner une valeur par d\u00e9faut aux attributs statiques et constantes directement dans le fichier d'en-t\u00eate. C++11 \u00e9tend cette possibilit\u00e9 aux attributs des classes : #include <iostream> using namespace std ; class X { public : X () {} explicit X ( int valeur ) : valeur ( valeur ) {} int getValeur () const { return valeur ; } private : int valeur = 1 ; // pour tous les constructeurs }; int main () { X x1 ; X x2 ( 2 ); cout << \"x1 = \" << x1 . getValeur () << \" (\" << sizeof ( x1 ) << \" octets)\" << endl ; cout << \"x2 = \" << x2 . getValeur () << \" (\" << sizeof ( x2 ) << \" octets)\" << endl ; //cout << \"Membre valeur -> \" << sizeof(X::valeur) << \" octets\" << endl; // si membre public return 0 ; }","title":"Initialisation"},{"location":"#auto","text":"Il est aussi possible de laisser le compilateur d\u00e9duire le type \u00e0 la compilation en utilisant le mot-cl\u00e9 auto : #include <iostream> using namespace std ; int main () { auto booleen = false ; // bool auto ch = 'c' ; // char auto i = 10 ; // int auto f = 1.5 ; // double auto s = \"string\" ; // char * cout << \"booleen = \" << booleen << \" (\" << sizeof ( booleen ) << \" octet)\" << endl ; cout << std :: boolalpha << \"booleen = \" << booleen << \" (\" << sizeof ( booleen ) << \" octet)\" << endl ; cout << \"ch = \" << ch << \" (\" << sizeof ( ch ) << \" octet)\" << endl ; cout << \"i = \" << i << \" (\" << sizeof ( i ) << \" octets)\" << endl ; cout << \"f = \" << f << \" (\" << sizeof ( f ) << \" octets)\" << endl ; cout << \"s = \" << s << \" (\" << sizeof ( s ) << \" octets)\" << endl ; vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; cout << \"v : \" ; for ( auto it = v . begin (); it != v . end (); ++ it ) { cout << * it << ' ' ; } cout << '\\n' ; // ou avec range-for cout << \"v : \" ; for ( auto i : v ) // i est un int { cout << i << ' ' ; } cout << '\\n' ; return 0 ; }","title":"auto"},{"location":"#membre-mutable","text":"Dans une fonction const , il est impossible de modifier un attribut (une variable membre) sauf si ce membre est pr\u00e9fix\u00e9 du mot-cl\u00e9 mutable . Remarque : Un membre mutable n'est jamais const ! Lien : mutable specifier #include <iostream> using namespace std ; class X { public : X () : x ( 0 ) {} int getX () const { return x ; }; void foo () const ; private : mutable int x = 0 ; }; void X::foo () const { ++ x ; } int main () { X unObjetX ; cout << \"x = \" << unObjetX . getX () << endl ; unObjetX . foo (); cout << \"x = \" << unObjetX . getX () << endl ; return 0 ; }","title":"Membre mutable"},{"location":"#les-pointeurs","text":"Il faut maintenant utiliser nullptr \u00e0 la place de 0 ou NULL pour initialiser un pointeur : #include <iostream> using namespace std ; int main () { int j = 20 ; int * pj = nullptr ; cout << \"j = \" << j << \" (\" << sizeof ( j ) << \" octets)\" << endl ; cout << \"&j = \" << & j << \" (\" << sizeof ( & j ) << \" octets)\" << endl ; cout << \"pj = \" << pj << \" (\" << sizeof ( pj ) << \" octets)\" << endl ; if ( pj != nullptr ) cout << \"*pj = \" << * pj << \" (\" << sizeof ( * pj ) << \" octets)\" << endl ; pj = & j ; * pj = 30 ; cout << \"j = \" << j << \" (\" << sizeof ( j ) << \" octets)\" << endl ; cout << \"&j = \" << & j << \" (\" << sizeof ( & j ) << \" octets)\" << endl ; cout << \"pj = \" << pj << \" (\" << sizeof ( pj ) << \" octets)\" << endl ; if ( pj ) cout << \"*pj = \" << * pj << \" (\" << sizeof ( * pj ) << \" octets)\" << endl ; return 0 ; }","title":"Les pointeurs"},{"location":"#les-pointeurs-intelligents","text":"Un pointeur intelligent ( smart pointer ) est un type abstrait de donn\u00e9es qui simule le comportement d'un pointeur en y ajoutant des fonctionnalit\u00e9s telles que la lib\u00e9ration automatique de la m\u00e9moire allou\u00e9e ou la v\u00e9rification des bornes. En C++11, les pointeurs intelligents sont impl\u00e9ment\u00e9s \u00e0 l'aide de templates qui \"imitent\" le comportement des pointeurs gr\u00e2ce \u00e0 la surcharge des op\u00e9rateurs, tout en fournissant des algorithmes de gestion m\u00e9moire. unique_ptr est une classe qui poss\u00e8de un membre qui pointe sur une ressource (objet) non partageable. unique_ptr g\u00e8re l'objet point\u00e9 en devenant responsable de sa suppression lorsqu'il passe hors de port\u00e9e. Lien : unique_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { unique_ptr < Point > p1 ( new Point ( 10 , 5 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; cout << p1 -> getX () << \",\" << p1 -> getY () << endl ; unique_ptr < Point > p2 ( move ( p1 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; unique_ptr < Point > p3 ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; //p3 = p2; // erreur ! return 0 ; } Les shared_ptr impl\u00e9mentent le comptage de r\u00e9f\u00e9rences, ce qui permet de partager l'objet poss\u00e9d\u00e9 par un shared_ptr entre plusieurs shared_ptr sans se soucier de comment lib\u00e9rer la m\u00e9moire associ\u00e9e. Lorsque le dernier shared_ptr est d\u00e9truit, l'objet point\u00e9 est \u00e9galement d\u00e9truit. Lien : shared_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { shared_ptr < Point > p1 ( new Point ( 10 , 5 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p1 : \" << p1 . use_count () << endl ; cout << p1 -> getX () << \",\" << p1 -> getY () << endl ; shared_ptr < Point > p2 ( move ( p1 )); std :: cout << \"p1 : \" << ( p1 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p1 : \" << p1 . use_count () << endl ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p2 : \" << p2 . use_count () << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; shared_ptr < Point > p3 ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p3 : \" << p3 . use_count () << endl ; p3 = p2 ; std :: cout << \"p2 : \" << ( p2 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p2 : \" << p2 . use_count () << endl ; std :: cout << \"p3 : \" << ( p3 ? \"not null\" : \"null\" ) << endl ; std :: cout << \"compteur p3 : \" << p3 . use_count () << endl ; cout << p2 -> getX () << \",\" << p2 -> getY () << endl ; cout << p3 -> getX () << \",\" << p3 -> getY () << endl ; return 0 ; } Les weak_ptr permettent de voir et d'acc\u00e9der \u00e0 une ressource (objet) poss\u00e9d\u00e9e par un shared_ptr mais n'ont aucune influence sur la destruction de ce dernier. Ils servent principalement \u00e0 s'affranchir du probl\u00e8me des r\u00e9f\u00e9rences circulaires. Lien : weak_ptr #include <iostream> #include <memory> using namespace std ; class Point { private : double x ; double y ; public : Point () : Point ( 0. , 0. ) { } Point ( double x , double y ) : x ( x ), y ( y ) { cout << __FUNCTION__ << endl ; } Point ( const Point & p ) : x ( p . x ), y ( p . y ) { cout << __FUNCTION__ << endl ; } ~ Point () { cout << __FUNCTION__ << endl ; } double getX () const { return x ; } double getY () const { return y ; } }; int main () { shared_ptr < Point > p1 ( new Point ( 10 , 5 )); weak_ptr < Point > wp1 ; weak_ptr < Point > wp2 ( wp1 ); weak_ptr < Point > wp3 ( p1 ); cout << \"use_count wp1 : \" << wp1 . use_count () << '\\n' ; cout << \"use_count wp2 : \" << wp2 . use_count () << '\\n' ; cout << \"use_count wp3 : \" << wp3 . use_count () << '\\n' ; return 0 ; }","title":"Les pointeurs intelligents"},{"location":"#les-enumerations","text":"De mani\u00e8re g\u00e9n\u00e9rale, les \u00e9num\u00e9rations permettent de grouper des ensembles de valeurs dans un type distinct. Il y a quelques limitations (donc probl\u00e8mes !) dans l'utilisation du type enum : #include <iostream> using namespace std ; int main () { // Probl\u00e8me n\u00b01 : Deux \u00e9num\u00e9rations ne peuvent pas partager les m\u00eames noms enum Genre { Masculin , Femimin }; enum GenrePersonne { Masculin , Femimin }; // error: redeclaration of 'Masculin' Genre genre = Masculin ; GenrePersonne genrePersonne = Femimin ; cout << \"genre = \" << genre << endl ; cout << \"genrePersonne = \" << genrePersonne << endl ; // Probl\u00e8me n\u00b02 : Aucune variable ne peut avoir un nom d\u00e9j\u00e0 utilis\u00e9 dans une \u00e9num\u00e9ration int Masculin = 10 ; // error: 'int Masculin' redeclared as different kind of symbol cout << \"Masculin = \" << Masculin << endl ; // Probl\u00e8me n\u00b03 : Les \u00e9num\u00e9rations ne sont pas un type compl\u00e9tement s\u00e9curis\u00e9 enum Couleur { Rouge , Vert , Bleu }; Couleur couleur = Rouge ; if ( genre == couleur ) //warning: comparison between 'enum main()::Genre' and 'enum main()::Couleur' cout << \"\u00c9gal !\" ; return 0 ; } C++11 a introduit des classes enum (appel\u00e9es \u00e9num\u00e9rations \u00e9tendues) qui rendent les \u00e9num\u00e9rations fortement typ\u00e9es. L'\u00e9num\u00e9ration de classe ne permet pas la conversion implicite en int et ne compare pas non plus les \u00e9num\u00e9rateurs de diff\u00e9rentes \u00e9num\u00e9rations. Lien : enum Syntaxe : enum class name { enumerator = constexpr , enumerator = constexpr , ... } // constexpr = 0 par d\u00e9faut enum class name : type { enumerator = constexpr , enumerator = constexpr , ... } enum class name ; // int par d\u00e9faut enum class name : type ; Exemple : #include <iostream> using namespace std ; int main () { enum class Genre { Masculin , Femimin }; enum class GenrePersonne { Masculin , Femimin }; Genre genre = Genre :: Masculin ; GenrePersonne genrePersonne = GenrePersonne :: Femimin ; cout << \"genre = \" << int ( genre ) << endl ; cout << \"genrePersonne = \" << int ( genrePersonne ) << endl ; int Masculin = 10 ; cout << \"Masculin = \" << Masculin << endl ; /*enum class Couleur { Rouge, Vert, Bleu }; Couleur couleur = Couleur::Rouge; if (genre == couleur) // error: no match for 'operator==' (operand types are 'main()::Genre' and 'main()::Couleur') cout << \"\u00c9gal !\";*/ return 0 ; }","title":"Les \u00e9num\u00e9rations"},{"location":"#decltype","text":"Le mot-cl\u00e9 decltype , introduit dans C++11, permet de d\u00e9finir une expression pour exprimer une d\u00e9claration de type. decltype \u00ab retourne \u00bb un type. Lien : decltype #include <iostream> using namespace std ; struct X { int i ; double d ; }; int main () { X x ; decltype ( x ) y ; // le type de y est X decltype ( x . i ) e ; // le type de e est int return 0 ; } Remarque : decltype est notamment int\u00e9ressant dans l'\u00e9criture de biblioth\u00e8ques g\u00e9n\u00e9riques \u00e0 base de templates. Sinon il est fort probable que vous n'ayez pas \u00e0 vous en servir.","title":"decltype"},{"location":"#les-litteraux-utilisateur","text":"C++ fournit un certain nombre de litt\u00e9raux. Les caract\u00e8res 12.5 sont un litt\u00e9ral qui est r\u00e9solu par le compilateur comme un type double . Avec l'ajout du suffixe f ( 12.5f ) le compilateur interpr\u00e9tera la valeur comme un type float . Les modificateurs de suffixe (comme U pour unsigned ou L pour long ) pour les litt\u00e9raux sont fix\u00e9s par la sp\u00e9cification C++. \u00c0 partir de C++11, il est possible de d\u00e9finir ses propres litt\u00e9raux afin de fournir des suffixes syntaxiques qui am\u00e9liore la lisibilit\u00e9 et renforce la s\u00e9curit\u00e9 des types. Lien : user_literal La biblioth\u00e8que standard a elle-m\u00eame d\u00e9fini des litt\u00e9raux pour std::complex et pour les unit\u00e9s dans les op\u00e9rations de temps dans std::chrono : complex < double > n = ( 2.0 + 3.0 i ) * 4 ; cout << \"n = (2 + 3i) x 4\" << endl ; cout << \"n = \" << n << endl ; cout << \"partie r\u00e9elle de n = \" << n . real () << endl ; cout << \"partie imaginaire de n = \" << n . imag () << endl ; cout << endl ; auto recordDuMonde = 2 h + 1 min + 39 s ; cout << \"Record du monde du Marathon : 2 h 01 min 39 s (Eliud Kipchoge en 2018)\" << endl ; cout << \"recordDuMonde = \" << recordDuMonde . count () << \" s\" << endl ; Liens : complex chrono C++ 11 permet donc \u00e0 l'utilisateur de d\u00e9finir de nouveaux types de modificateurs litt\u00e9raux qui construiront des objets bas\u00e9s sur la cha\u00eene de caract\u00e8res que le litt\u00e9ral modifie. La transformation des litt\u00e9raux est red\u00e9finie en deux phases distinctes : raw (brut) et cooked (pr\u00e9par\u00e9). Un litt\u00e9ral raw est une s\u00e9quence de caract\u00e8res d'un type sp\u00e9cifique, tandis que le litt\u00e9ral cooked est d'un type distinct. Le litt\u00e9ral 1234 , en tant que litt\u00e9ral raw , est la s\u00e9quence de caract\u00e8res '1', '2', '3' et '4'. En tant que litt\u00e9ral cooked , il s'agit de l'entier 1234 . Le litt\u00e9ral 0xA est '0', 'x', 'A' soit l'entier 10 . Liens : raw cooked Tous les litt\u00e9raux d\u00e9finis par l'utilisateur seront des suffixes . La d\u00e9finition de litt\u00e9raux de pr\u00e9fixe n'est pas possible. Tous les suffixes commen\u00e7ant par n'importe quel caract\u00e8re sauf le trait de soulignement ( _ ) sont r\u00e9serv\u00e9s par la norme. Ainsi, tous les litt\u00e9raux d\u00e9finis par l'utilisateur doivent avoir des suffixes commen\u00e7ant par un trait de soulignement ( _ ). Les litt\u00e9raux utilisateur sont d\u00e9finis via un op\u00e9rateur litt\u00e9ral qui se nomme operator \"\" . en.wikipedia.org Pour les litt\u00e9raux num\u00e9riques, le type du litt\u00e9ral est unsigned long long pour les litt\u00e9raux entiers ou long double pour les litt\u00e9raux \u00e0 virgule flottante. ( Remarque : il n'est pas n\u00e9cessaire d'utiliser des types int\u00e9graux sign\u00e9s car un litt\u00e9ral avec un pr\u00e9fixe de signe est analys\u00e9 comme une expression contenant le signe en tant qu'op\u00e9rateur de pr\u00e9fixe unaire operator - , qu'il est possible de surcharger, et le nombre non sign\u00e9.) On va d\u00e9finir une classe Temperature . Il sera alors possible de d\u00e9finir un litt\u00e9ral pour les degr\u00e9s Celsius et un autre pour les Fahrenheit. Ensuite, on sera forc\u00e9 d'exprimer explicitement l'unit\u00e9 de mesure en \u00e9crivant par exemple : auto t1 = 36.5_celsius ou auto t2 = 32.0_fahrenheit . #include <iostream> using namespace std ; class Temperature { private : long double temperature = { 0 }; // en celsius explicit Temperature ( long double valeur ) : temperature ( valeur ) { } friend Temperature operator \"\" _celsius ( long double valeur ); // pour une valeur en virgule flottante friend Temperature operator \"\" _celsius ( unsigned long long valeur ); // pour une valeur enti\u00e8re friend Temperature operator \"\" _fahrenheit ( long double valeur ); friend Temperature operator \"\" _kelvin ( long double valeur ); public : constexpr static long double zero_absolu = 273.15 ; // en celsius long double celsius () { return temperature ; } long double fahrenheit () { return ( temperature * 9. / 5. ) + 32. ; } long double kelvin () { return ( temperature + Temperature :: zero_absolu ); } Temperature operator + ( Temperature t ) { return Temperature ( celsius () + t . celsius ()); } friend Temperature operator - ( Temperature t ); }; Temperature operator \"\" _celsius ( long double valeur ) // pour une valeur en virgule flottante { return Temperature ( valeur ); } Temperature operator \"\" _celsius ( unsigned long long valeur ) // pour une valeur enti\u00e8re { return Temperature ( double ( valeur )); } Temperature operator \"\" _fahrenheit ( long double valeur ) { return Temperature (( 5. / 9. ) * ( valeur - 32. )); } Temperature operator \"\" _kelvin ( long double valeur ) { return Temperature ( valeur - Temperature :: zero_absolu ); } Temperature operator - ( Temperature t ) { return Temperature (( -1. ) * t . celsius ()); } int main () { Temperature zeroCelsius = 32. _fahrenheit ; //Temperature zeroCelsius = 0_celsius; cout << \"zeroCelsius = \" << zeroCelsius . celsius () << \"C \" << zeroCelsius . kelvin () << \"K \" << zeroCelsius . fahrenheit () << \"F \" << endl ; Temperature zeroAbsolu = 0. _kelvin ; cout << \"zeroAbsolu = \" << zeroAbsolu . celsius () << \"C \" << zeroAbsolu . kelvin () << \"K \" << zeroAbsolu . fahrenheit () << \"F \" << endl ; Temperature t1 = 36.0 _celsius + 42.0 _celsius ; cout << \"t1 = 36.0_celsius + 42.0_celsius\" << endl ; cout << \"t1 = \" << t1 . celsius () << \"C \" << t1 . kelvin () << \"K \" << t1 . fahrenheit () << \"F \" << endl ; Temperature t2 = 36.0 _celsius + -42.0 _celsius ; cout << \"t2 = 36.0_celsius + -42.0_celsius\" << endl ; cout << \"t2 = \" << t2 . celsius () << \"C \" << t2 . kelvin () << \"K \" << t2 . fahrenheit () << \"F \" << endl ; auto t3 = 36.0 _celsius ; cout << \"t3 = \" << t3 . celsius () << \"C \" << t3 . kelvin () << \"K \" << t3 . fahrenheit () << \"F \" << endl ; auto t4 = 36 _celsius ; cout << \"t4 = \" << t4 . celsius () << \"C \" << t4 . kelvin () << \"K \" << t4 . fahrenheit () << \"F \" << endl ; // Evidemment, ceci n'est plus possible : //Temperature t5 = 25; // error: conversion from 'int' to non-scalar type 'Temperature' requested //Temperature t5 = 25.; // error: conversion from 'double' to non-scalar type 'Temperature' requested //Temperature t5 = 36_fahrenheit; // error: unable to find numeric literal operator 'operator\"\"_fahrenheit' -> il faudrait donc surcharger operator\"\" _fahrenheit(unsigned long long valeur) return 0 ; }","title":"Les litt\u00e9raux utilisateur"},{"location":"#range-for","text":"Introduit en C++11, la boucle Range-for ex\u00e9cute une boucle for sur une plage de valeurs, telles que tous les \u00e9l\u00e9ments d'un conteneur. Lien : range-for #include <iostream> #include <vector> using namespace std ; int main () { string str = \"Hello world!\" ; for ( char c : str ) { cout << c ; } cout << '\\n' ; std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; for ( const auto & i : v ) // acces par r\u00e9f\u00e9rence constante cout << i << ' ' ; cout << '\\n' ; for ( auto i : v ) // acces par valeur (i est de type int) cout << i << ' ' ; cout << '\\n' ; int t [] = { 0 , 1 , 2 , 3 , 4 , 5 }; for ( auto n : t ) // avec un tableau cout << n << ' ' ; cout << '\\n' ; for ( auto p : { 2 , 4 , 6 }) // avec des constantes cout << p << ' ' ; cout << '\\n' ; return 0 ; }","title":"Range-for"},{"location":"#les-expressions-rationnelles","text":"La biblioth\u00e8que C++ standard prend maintenant (en C++11) en charge les expressions rationnelles ( Regular Expressions ) avec l'en-t\u00eate <regex> via une s\u00e9rie d'op\u00e9rations : regex_match : correspondance exacte avec une expression rationnelle ; regex_search : recherche correspondance avec une expression rationnelle ; regex_replace : recherche correspondance avec une expression rationnelle et la remplace ; Liens : regex Syntaxe ECMAScript #include <iostream> #include <regex> using namespace std ; int main () { string str = \"Le code postal de Sarrians est 84260 et 84000 celui d'Avignon.\" ; regex reg { R \" ( \\d{5}? ) \" }; smatch matches ; while ( regex_search ( str , matches , reg )) { for ( auto x : matches ) std :: cout << x << \" \" ; cout << endl ; //cout << matches.suffix().str() << endl; str = matches . suffix (). str (); } return 0 ; }","title":"Les expressions rationnelles"},{"location":"#delegation-du-constructeur","text":"En C++03, un constructeur appartenant \u00e0 une classe ne peut pas appeler un autre constructeur de cette m\u00eame classe, ce qui peut entra\u00eener de la duplication de code lors de l'initialisation de ses attributs. En permettant au constructeur de d\u00e9l\u00e9guer la cr\u00e9ation d'une instance \u00e0 un autre constructeur, C++11 apporte donc une solution. #include <iostream> using namespace std ; class Nombre { public : Nombre ( int nombre ) : nombre ( nombre ) {} Nombre () : Nombre ( 42 ) {} int getNombre () const { return nombre ; } private : int nombre ; }; int main () { Nombre n1 ; Nombre n2 ( 2 ); cout << \"n1 = \" << n1 . getNombre () << endl ; cout << \"n2 = \" << n2 . getNombre () << endl ; return 0 ; }","title":"D\u00e9l\u00e9gation du constructeur"},{"location":"#heritage-des-constructeurs","text":"En C++03, les constructeurs d'une classe de base ne sont pas h\u00e9rit\u00e9s par ses classes d\u00e9riv\u00e9es. C++11 permet d'h\u00e9riter explicitement des constructeurs de la classe de base gr\u00e2ce \u00e0 l'instruction using : #include <iostream> using namespace std ; class Point { public : Point ( double x , double y ) : x ( x ), y ( y ) {} Point () : x ( 0. ), y ( 0. ) {} friend ostream & operator << ( ostream & os , const Point & p ); private : double x ; double y ; }; ostream & operator << ( ostream & os , const Point & p ) { os << \"<\" << p . x << \",\" << p . y << \">\" ; return os ; } class PointCouleur : public Point { public : using Point :: Point ; //... private : unsigned int couleur ; }; int main () { PointCouleur p1 ; PointCouleur p2 ( 2 , 2 ); cout << p1 << endl ; cout << p2 << endl ; return 0 ; }","title":"H\u00e9ritage des constructeurs"},{"location":"#liste-dinitialiseurs","text":"C++11 introduit le patron de classe std::initializer_list qui permet d'initialiser les conteneurs avec une suite de valeurs entre accolades. std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; // ou : std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 }; // ou avec une map : std :: map < string , int > m { { \"a\" , 1 }, { \"b\" , 2 }, { \"c\" , 3 }, { \"d\" , 4 }, { \"e\" , 5 }, { \"f\" , 6 } }; Lien : initializer_list #include <vector> #include <iostream> using namespace std ; template < class T > class MonVecteur { public : MonVecteur ( initializer_list < T > liste ) : v ( liste ) {} void append ( std :: initializer_list < T > liste ) { v . insert ( v . end (), liste . begin (), liste . end ()); } //private: vector < T > v ; }; int main () { MonVecteur < int > mv = { 1 , 2 , 3 , 4 , 5 }; mv . append ({ 6 , 7 , 8 }); std :: cout << \"mv : \" ; for ( auto i : mv . v ) { std :: cout << i << ' ' ; } std :: cout << '\\n' ; return 0 ; }","title":"Liste d'initialiseurs"},{"location":"#constexpr","text":"Le mot cl\u00e9 constexpr a \u00e9t\u00e9 introduit dans C++11 et am\u00e9lior\u00e9 en C++14. constexpr d\u00e9clare un objet utilisable dans ce que la norme appelle des expressions constantes. Comme const , constexpr peut \u00eatre utilis\u00e9 sur des variables mais aussi des fonctions et des constructeurs. Lien : constexpr #include <iostream> using namespace std ; constexpr size_t getTaille () { return 10 ; } constexpr size_t getTaille ( int n ) { return 10 * n ; } int main () { constexpr float x = 42.0 ; constexpr int N = 5 ; int t1 [ N ] = { 1 , 2 , 3 , 4 , 5 }; // 5 x 4 int t2 [ getTaille ()]; // 10 x 4 int t3 [ getTaille ( 2 )]; // 2 x 10 x 4 cout << \"taille t1 = \" << sizeof ( t1 ) << \" octets\" << endl ; cout << \"taille t2 = \" << sizeof ( t2 ) << \" octets\" << endl ; cout << \"taille t3 = \" << sizeof ( t3 ) << \" octets\" << endl ; return 0 ; }","title":"constexpr"},{"location":"#les-nouveaux-specificateurs-de-classe-override-default-delete-final","text":"Le sp\u00e9cificateur default permet de demander explicitement la g\u00e9n\u00e9ration automatique de la m\u00e9thode correspondante. On l'utilise par exemple pour le constructeur de copie, le destructeur et l'op\u00e9rateur de copie : #include <iostream> using namespace std ; struct Coordonnee { double x ; double y ; Coordonnee () : x ( 0. ), y ( 0. ) {} Coordonnee ( double x , double y ) : x ( x ), y ( y ) {} }; class Point { private : Coordonnee coordonnee ; public : // Constructeurs Point () {} Point ( double x , double y ) : coordonnee ( x , y ) {} Point ( const Point & point ) = default ; // constructeur de copie // Destructeur ~ Point () = default ; // Accesseurs et mutateurs double getX () const { return coordonnee . x ; } void setX ( double x ) { this -> coordonnee . x = x ; } double getY () const { return coordonnee . y ; } void setY ( double y ) { this -> coordonnee . y = y ; } // Surcharge Point & operator = ( const Point & point ) = default ; // copie friend ostream & operator << ( ostream & os , const Point & point ); }; ostream & operator << ( ostream & os , const Point & point ) { os << \"<\" << point . coordonnee . x << \",\" << point . coordonnee . y << \">\" ; return os ; } int main () { cout << \"Les points :\" << endl ; Point p0 , p1 ( 4 , 0.0 ), p2 ( 2.5 , 2.5 ); cout << \"p0 = \" << p0 << endl ; cout << \"p1 = \" << p1 << endl ; cout << \"p2 = \" << p2 << endl ; cout << \"Constructeur de copie : Point p3(p2)\" << endl ; Point p3 ( p2 ); cout << \"p3 = \" << p3 << endl ; cout << \"Op\u00e9rateur de copie : p0 = p3\" << endl ; p0 = p3 ; cout << \"p0 = \" << p0 << endl ; return 0 ; } Inversement, le sp\u00e9cificateur delete interdira la g\u00e9n\u00e9ration automatique de la m\u00e9thode correspondante. Utilis\u00e9 pour un constructeur de copie et l'op\u00e9rateur de copie, cela rend les objets de cette classe non copiable : class Point { private : Coordonnee coordonnee ; public : // Constructeurs Point () {} Point ( double x , double y ) : coordonnee ( x , y ) {} Point ( const Point & point ) = delete ; // constructeur de copie // Destructeur ~ Point () = default ; // Accesseurs et mutateurs double getX () const { return coordonnee . x ; } void setX ( double x ) { this -> coordonnee . x = x ; } double getY () const { return coordonnee . y ; } void setY ( double y ) { this -> coordonnee . y = y ; } // Surcharge Point & operator = ( const Point & point ) = delete ; // copie friend ostream & operator << ( ostream & os , const Point & point ); }; On obtient alors les erreurs suivantes : error: use of deleted function \u2018Point::Point(const Point&)' Point p3(p2); note: declared here Point(const Point& point) = delete; error: use of deleted function \u2018Point& Point::operator=(const Point&)' p0 = p3; note: declared here Point& operator=(const Point& point) = delete; Dans la pratique : Si un constructeur est d\u00e9clar\u00e9 explicitement, aucun constructeur par d\u00e9faut n'est automatiquement g\u00e9n\u00e9r\u00e9. Si un destructeur virtuel est d\u00e9clar\u00e9 explicitement, aucun destructeur par d\u00e9faut n'est automatiquement g\u00e9n\u00e9r\u00e9. Si un constructeur de d\u00e9placement ou un op\u00e9rateur d'assignation de d\u00e9placement est d\u00e9clar\u00e9 explicitement : Aucun constructeur de copie n'est g\u00e9n\u00e9r\u00e9 automatiquement. Aucun op\u00e9rateur d'assignation de copie n'est g\u00e9n\u00e9r\u00e9 automatiquement. Si un constructeur de copie, un op\u00e9rateur d'assignation de copie, un constructeur de d\u00e9placement, un op\u00e9rateur d'assignation de mouvement ou un destructeur est d\u00e9clar\u00e9 explicitement : Aucun constructeur de d\u00e9placement n'est g\u00e9n\u00e9r\u00e9 automatiquement. Aucun op\u00e9rateur d'assignation de d\u00e9placement n'est g\u00e9n\u00e9r\u00e9 automatiquement. De plus, la norme C++11 sp\u00e9cifie les r\u00e8gles suppl\u00e9mentaires suivantes : Si un constructeur de copie ou un destructeur est d\u00e9clar\u00e9 explicitement, la g\u00e9n\u00e9ration automatique de l'op\u00e9rateur d'assignation de copie est d\u00e9conseill\u00e9e. Si un op\u00e9rateur d'assignation de copie ou un destructeur est d\u00e9clar\u00e9 explicitement, la g\u00e9n\u00e9ration automatique du constructeur de copie est d\u00e9conseill\u00e9e. Dans une d\u00e9claration ou une d\u00e9finition de m\u00e9thode, le sp\u00e9cificateur override garantit que la fonction membre est virtuelle et remplace une m\u00e9thode virtuelle d'une classe de base. class A { public : virtual void foo (); // une m\u00e9thode virtuelle void bar (); // une m\u00e9thode \"normale\" (non virtuelle) }; class B : public A { public : void foo () const override ; // Erreur : signature diff\u00e9rente void foo () override ; // Ok : B::foo() remplace A::foo() void bar () override ; // Erreur : A::bar() n'est pas une m\u00e9thode virtuelle }; int main () { // ... return 0 ; } Remarque : override permet d'\u00e9noncer que l'on fait une surcharge et le compilateur en assurera le contr\u00f4le ! Il est donc fortement conseill\u00e9 d'utiliser syst\u00e8matiquement override . Inversement, le sp\u00e9cificateur final garantit que la m\u00e9thode est virtuelle et sp\u00e9cifie qu'elle ne peut pas \u00eatre remplac\u00e9e par des classes d\u00e9riv\u00e9es. Lorsqu'il est utilis\u00e9 dans une d\u00e9finition de classe, final sp\u00e9cifie que cette classe ne peut pas \u00eatre d\u00e9riv\u00e9e. class Base { public : virtual void foo (); // une m\u00e9thode virtuelle }; class A : public Base // A h\u00e9rite (est d\u00e9riv\u00e9e) de Base { void foo () final ; // Ok : Base::foo() est remplac\u00e9e et A::foo() ne sera pas remplac\u00e9e void bar () final ; // Erreur : A::bar() n'est pas une m\u00e9thode virtuelle }; class B final : public A // B h\u00e9rite (est d\u00e9riv\u00e9e) de A et ne sera pas d\u00e9rivable { void foo () override ; // Erreur: foo() n'est pas rempla\u00e7able car final dans A }; class C : public B // Erreur : B est final { }; int main () { // ... return 0 ; } Remarque : final permet de se prot\u00e9ger d'un remplacement non d\u00e9sir\u00e9 et le compilateur en assurera le contr\u00f4le ! Il est donc fortement conseill\u00e9 d'utiliser syst\u00e8matiquement final .","title":"Les nouveaux sp\u00e9cificateurs de classe (override, default, delete, final)"},{"location":"#reference-sur-rvalue","text":"Chaque expression C++ a un type et appartient \u00e0 une cat\u00e9gorie de valeur ( lvalue , rvalue , ...). Pour rappel, une lvalue ( left value ou valeur \u00e0 gauche) peut appara\u00eetre \u00e0 gauche d'un op\u00e9rateur d'affectation (un nom de variable par exemple). Une rvalue ( right value ou valeur \u00e0 droite) peut appara\u00eetre \u00e0 droite d'un op\u00e9rateur d'affectation (une expression par exemple). Maintenant, une rvalue peut \u00eatre une prvalue ( pure value ) ou xvalue ( eXpiring value ). Une prvalue est une expression dont l'\u00e9valuation : calcule une valeur qui n'est pas associ\u00e9e \u00e0 un objet ou cr\u00e9e un objet temporaire et le d\u00e9signe Une xvalue est une glvalue qui d\u00e9signe un objet dont les ressources peuvent \u00eatre r\u00e9utilis\u00e9es. Une glvalue ( generalized lvalue ) est une expression dont l'\u00e9valuation d\u00e9termine l'identit\u00e9 d'un objet. int a = 2 + 3 ; // a est une lvalue // 2 + 3 est une rvalue // l'expression 2 + 3 est \u00e9valu\u00e9e \u00e0 5 et cette valeur temporaire (et non nomm\u00e9e) est affect\u00e9e \u00e0 la lvalue a // Idem pour des objets Point p1 , p2 ; // deux objets Point Point p = p1 + p2 ; // p est une lvalue // p1 + p2 est une rvalue // l'expression p1 + p2 est \u00e9valu\u00e9e (si l'op\u00e9rateur + est surcharg\u00e9 pour la classe Point) et un nouvel objet Point est cr\u00e9\u00e9 temporairement (et non nomm\u00e9) pour \u00eatre affect\u00e9 \u00e0 l'objet p (si l'op\u00e9rateur = est surcharg\u00e9 pour la classe Point) Lien : value_category Il est possible de cr\u00e9er des r\u00e9f\u00e9rences sur des lvalue (avec l'op\u00e9rateur \u00ab & \u00bb) et en C++11 sur des rvalue (avec l'op\u00e9rateur \u00ab && \u00bb) : void foo ( int & x ) // ici x est une r\u00e9f\u00e9rence sur une lvalue (et x est une lvalue) { cout << \"foo(int x) -> \" << x << endl ; } void foo ( int && x ) // ici x est une r\u00e9f\u00e9rence sur une rvalue (et x est une lvalue) { cout << \"foo(int&& x) -> \" << x << endl ; } int main () { // Pour rappel : int a = 2 ; // a est une lvalue int & ra = a ; // ra est une r\u00e9f\u00e9rence sur la lvalue 'a' int && rvb = 42 ; // rvb est une r\u00e9f\u00e9rence sur une rvalue int b = 2 ; // b est un lvalue foo ( b ); // passage d'une lvalue foo ( 42 ); // passage d'une rvalue return 0 ; } On obtient : foo(int x) -> 2 foo(int&& x) -> 42 Les r\u00e9f\u00e9rences sur rvalue prennent en charge l'impl\u00e9mentation de la notion de d\u00e9placement (ce qui am\u00e9liorera les performances en \u00e9vitant des copies inutiles). La notion de d\u00e9placement est l'id\u00e9e de transf\u00e8rer les ressources (telles que la m\u00e9moire allou\u00e9e de mani\u00e8re dynamique) d'un objet vers un autre sans avoir \u00e0 le copier.","title":"R\u00e9f\u00e9rence sur rvalue"},{"location":"#la-fonction-move","text":"La fonction std::move() retourne une r\u00e9f\u00e9rence rvalue sur l'objet pass\u00e9 en argument. Il s'agit d'une fonction de service pour utiliser la notion (ou s\u00e9mantique) de d\u00e9placement . La notion de d\u00e9placement est l'id\u00e9e de transf\u00e8rer les ressources (telles que la m\u00e9moire allou\u00e9e de mani\u00e8re dynamique) d'un objet vers un autre sans avoir \u00e0 le copier. Dans la biblioth\u00e8que standard, le d\u00e9placement implique que l'objet d\u00e9plac\u00e9 est laiss\u00e9 dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9. Ce qui signifie qu'apr\u00e8s une telle op\u00e9ration, la valeur de l'objet d\u00e9plac\u00e9 ne doit \u00eatre que d\u00e9truite ou affect\u00e9e d'une nouvelle valeur; y acc\u00e9der donnera sinon une valeur non sp\u00e9cifi\u00e9e. Donc : dans une op\u00e9ration de d\u00e9placement ( move ), l'\u00e9tat de l'objet d\u00e9plac\u00e9 devient non d\u00e9fini. Cet objet ne doit plus \u00eatre utilis\u00e9. Qu'est-ce que cela veut dire ? Si on d\u00e9place un objet p1 dans un objet p2, l'\u00e9tat de p1 n'est plus disponible car il n'est plus d\u00e9fini. Il ne faut donc plus utiliser p1 (mais p1 reste un objet valide). Seul l'objet p2 est viable. Lien : move Exemples : int a = 2 ; // a est une lvalue int && rva = std :: move ( a ); // rva est une r\u00e9f\u00e9rence sur une rvalue Point p1 ( 2.5 , 2.5 ); Point && rp1 = std :: move ( p1 ); Point p2 ( 2.5 , 2.5 ); Point p3 ( std :: move ( p2 )); void swap ( Point & a , Point & b ) { Point tmp ( std :: move ( a )); a = std :: move ( b ); b = std :: move ( tmp ); } Point p4 ( 2.5 , 2.5 ), p5 ( 1. , 1. ); swap ( p4 , p5 ); Il est possible de \"convertir\" une lvalue en r\u00e9f\u00e9rence rvalue en utilisant donc la fonction std::move() ou static_cast : foo ( static_cast < int &&> ( b )); // la lvalue 'b' est cast\u00e9e en r\u00e9f\u00e9rence rvalue foo ( move ( b )); // move() retourne une r\u00e9f\u00e9rence rvalue sur 'b' On obtient : foo(int&& x) -> 2 foo(int&& x) -> 2","title":"La fonction move()"},{"location":"#deplacement-constructeur-et-operateur","text":"Le C++11 introduit un nouveau constructeur : le constructeur de d\u00e9placement. Sa signature sera : T(T&& t) . Son objectif est de \"voler\" les ressources de l'objet pass\u00e9 en param\u00e8tre tout en le laissant dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9 (cet objet pass\u00e9 en param\u00e8tre pourra par la suite \u00eatre d\u00e9truit ou recevoir une nouvelle valeur). L'objectif du constructeur de d\u00e9placement est donc d'\u00e9viter des copies inutiles et par cons\u00e9quence d'am\u00e9liorer les performances du programme. Exemples d'appel de constructeurs : Point p1 ; // constructeur par d\u00e9faut Point p2 ( p1 ); // constructeur de copie Point p3 ( Point ()); // constructeur de d\u00e9placement : Point() instancie un objet temporaire non nomm\u00e9 pass\u00e9 par r\u00e9f\u00e9rence rvalue (inutile de le copier car il suffit de le \"d\u00e9placer\" en lui volant ses ressources) Le C++11 introduit un nouvel op\u00e9rateur d'affectation : l'op\u00e9rateur de d\u00e9placement. Sa signature sera : T& operator=(T&& t) . Son objectif est de \"voler\" les ressources de l'objet pass\u00e9 en param\u00e8tre tout en le laissant dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9 (cet objet pass\u00e9 en param\u00e8tre pourra par la suite \u00eatre d\u00e9truit ou recevoir une nouvelle valeur). L'objectif de l'op\u00e9rateur de d\u00e9placement est donc d'\u00e9viter des copies inutiles et par cons\u00e9quence d'am\u00e9liorer les performances du programme. Exemples d'appel de l'op\u00e9rateur d'affectation = : p1 = p2 ; // op\u00e9rateur d'affectation = de copie p3 = p1 + p2 ; // op\u00e9rateur d'affectation = de d\u00e9placement : (p1 + p2) g\u00e9n\u00e9re un objet temporaire non nomm\u00e9 pass\u00e9 par r\u00e9f\u00e9rence rvalue (inutile de le copier car il suffit de le \"d\u00e9placer\" en lui volant ses ressources) Le constructeur de d\u00e9placement et l'op\u00e9rateur de d\u00e9placement utilisent les r\u00e9f\u00e9rences sur rvalue . On peut leur ajouter le qualificateur noexcept s'ils ne lancent pas d'exception. Liens : move_constructor move_assignment Exemple pour une classe Point : struct Coordonnee { double x ; double y ; Coordonnee () : x ( 0. ), y ( 0. ) {} Coordonnee ( double x , double y ) : x ( x ), y ( y ) {} }; class Point { private : Coordonnee * coordonnee ; public : // Constructeurs Point () : coordonnee ( new Coordonnee ()) { } Point ( double x , double y ) : coordonnee ( new Coordonnee ( x , y )) { } Point ( const Point & point ); // copie Point ( Point && point ) noexcept ; // d\u00e9placement // Destructeur ~ Point () { if ( coordonnee ) delete coordonnee ; }; // Accesseurs et mutateurs double getX () const { return coordonnee -> x ; } void setX ( double x ) { this -> coordonnee -> x = x ; } double getY () const { return coordonnee -> y ; } void setY ( double y ) { this -> coordonnee -> y = y ; } // Surcharge Point & operator = ( const Point & point ); // copie Point & operator = ( Point && point ); // d\u00e9placement friend ostream & operator << ( ostream & os , const Point & point ); friend Point operator + ( const Point & p1 , const Point & p2 ); // Services (exemples) static void swap_v1 ( Point & a , Point & b ); static void swap_v2 ( Point & a , Point & b ); }; // Constructeur de copie Point :: Point ( const Point & point ) : coordonnee ( new Coordonnee ( point . coordonnee -> x , point . coordonnee -> y )) { } // Constructeur de d\u00e9placement (le \"vol\") Point :: Point ( Point && point ) noexcept : coordonnee ( point . coordonnee ) { point . coordonnee = nullptr ; } // Copie Point & Point :: operator = ( const Point & point ) { if ( this != & point ) { delete coordonnee ; coordonnee = new Coordonnee ( point . coordonnee -> x , point . coordonnee -> y ); } return * this ; } // D\u00e9placement Point & Point :: operator = ( Point && point ) { if ( this != & point ) { delete coordonnee ; coordonnee = point . coordonnee ; // \"vol\" point . coordonnee = nullptr ; // valide mais non sp\u00e9cifi\u00e9 } return * this ; } // Surcharge ostream & operator << ( ostream & os , const Point & point ) { os << \"<\" << point . coordonnee -> x << \",\" << point . coordonnee -> y << \">\" ; return os ; } Point operator + ( const Point & p1 , const Point & p2 ) { Point p ; p . coordonnee -> x = p1 . coordonnee -> x + p2 . coordonnee -> x ; p . coordonnee -> y = p1 . coordonnee -> y + p2 . coordonnee -> y ; return p ; } void Point :: swap_v1 ( Point & a , Point & b ) // par copie { Point tmp ( a ); // constructeur de copie a = b ; // op\u00e9rateur de copie b = tmp ; // op\u00e9rateur de copie } void Point :: swap_v2 ( Point & a , Point & b ) // par d\u00e9placement { Point tmp ( move ( a )); a = move ( b ); b = move ( tmp ); } Exemple n\u00b01 : le d\u00e9placement en action cout << \"points :\" << endl ; Point p2 , p3 ( 1. , 1. ), p4 ( 2.5 , 2.5 ); cout << \"p2 = \" << p2 << endl ; cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; cout << \"p2 = p3 + p4\" << endl ; p2 = p3 + p4 ; // move cout << \"p2 = \" << p2 << endl ; cout << endl ; cout << \"p5 <- p2\" << endl ; Point p5 ( move ( p2 )); // move cout << \"p5 = \" << p5 << endl ; cout << endl ; cout << \"p3 <-> p4\" << endl ; Point :: swap_v1 ( p3 , p4 ); // par copie cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; cout << \"p3 <-> p4\" << endl ; Point :: swap_v2 ( p3 , p4 ); // move cout << \"p3 = \" << p3 << endl ; cout << \"p4 = \" << p4 << endl ; cout << endl ; On obtient : points : default Point 0x7ffc389b1908 Point 0x7ffc389b1910 Point 0x7ffc389b1918 p2 = <0,0> p3 = <1,1> p4 = <2.5,2.5> p2 = p3 + p4 default Point 0x7ffc389b1920 move operator= 0x7ffc389b1908 p2 = <3.5,3.5> p5 <- p2 move Point 0x7ffc389b1920 p5 = <3.5,3.5> p3 <-> p4 copy Point 0x7ffc389b18c0 copy operator= 0x7ffc389b1910 copy operator= 0x7ffc389b1918 p3 = <2.5,2.5> p4 = <1,1> p3 <-> p4 move Point 0x7ffc389b18c0 move operator= 0x7ffc389b1910 move operator= 0x7ffc389b1918 p3 = <1,1> p4 = <2.5,2.5> Exemple n\u00b02 : am\u00e9lioration des performances auto start = std :: chrono :: high_resolution_clock :: now (); // d\u00e9marrage chronom\u00e8tre vector < Point > points ; for ( int i = 0 ; i < 1000000 ; ++ i ) { points . push_back ( Point ( i , i * 2 )); } //vector<Point> courbe(points); // test 1 : par copie vector < Point > courbe ( move ( points )); // test 2 : par d\u00e9placement reverse ( courbe . begin (), courbe . end ()); // pour s'amuser ;) auto end = chrono :: high_resolution_clock :: now (); // arr\u00eat chronom\u00e8tre chrono :: duration < double > elapsed = end - start ; // calcul du temps // Affichage des r\u00e9sultats cout << \"Duration : \" << elapsed . count () << \" s \\n \" ; cout << \"Constructions : \" << Point :: constructions << \" \\n \" ; cout << \"Copies : \" << Point :: copies << \" \\n \" ; cout << \"Deplacements : \" << Point :: deplacements << \" \\n \" ; cout << \"Total : \" << ( Point :: constructions + Point :: deplacements ) << \" \\n \" ; On obtient : par copie : Duration : 0.193734 s Constructions : 4548575 Copies : 1000000 Deplacements : 0 Total : 4548575 par d\u00e9placement : Duration : 0.0961808 s Constructions : 1000000 Copies : 0 Deplacements : 3548575 Total : 4548575","title":"D\u00e9placement (constructeur et op\u00e9rateur)"},{"location":"#threads","text":"C++11 fournit une classe pour repr\u00e9senter les threads d'ex\u00e9cution individuels. Un thread est un fil d'ex\u00e9cution (une s\u00e9quence d'instructions) qui peut \u00eatre ex\u00e9cut\u00e9 simultan\u00e9ment avec d'autres fils de ce type dans des environnements multithreading , tout en partageant un m\u00eame espace d'adressage. Un objet thread initialis\u00e9 repr\u00e9sente un thread d'ex\u00e9cution actif. Un tel objet thread est joignable et poss\u00e8de un identifiant de thread unique. Lien : thread Exemple avec un thread : #include <iostream> #include <thread> // $ g++ thread.cpp -lpthread using namespace std ; void unThread () { cout << \"Hello !\" << endl ; } int main () { thread hello ( unThread ); // cr\u00e9ation et lancement du thread hello . join (); // attendre la fin du thread return 0 ; } Exemple avec deux threads : #include <iostream> #include <thread> #include <chrono> // $ g++ thread-2.cpp -lpthread using namespace std ; void etoile () { for ( int i = 0 ; i < 10 ; ++ i ) { this_thread :: sleep_for ( chrono :: duration < int , milli > ( 250 )); cout << \"*\" ; } } void diese () { for ( int i = 0 ; i < 10 ; ++ i ) { this_thread :: sleep_for ( chrono :: duration < int , milli > ( 250 )); cout << \"#\" ; } } int main () { setbuf ( stdout , NULL ); thread t1 ( etoile ); // cr\u00e9ation et lancement du thread thread t2 ( diese ); // cr\u00e9ation et lancement du thread t1 . join (); // attendre la fin du thread t2 . join (); // attendre la fin du thread cout << endl ; return 0 ; } Voir aussi : call_once atomic","title":"Threads"},{"location":"#stdfuture-et-stdasync","text":"std::future est un objet qui peut r\u00e9cup\u00e9rer une valeur de mani\u00e8re synchronis\u00e9e. std::async permet d'appeler une fonction de mani\u00e8re asynchrone (sans attendre la fin de l'ex\u00e9cution de la fonction). La valeur retourn\u00e9e par la fonction sera accessible via l'objet future retourn\u00e9 lors de l'appel et en appelant sa m\u00e9thode get() . Liens : future async #include <iostream> #include <future> // pour async et future #include <chrono> // $ g++ future.cpp -lpthread using namespace std ; // la factorielle d'un entier naturel n est le produit des nombres entiers strictement positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 n long factorielle ( long n ) { return n > 1 ? ( n * factorielle ( n -1 )) : 1 ; // https://fr.wikipedia.org/wiki/Factorielle#Algorithme } // exemple : http://www.cplusplus.com/reference/future/future/ bool is_prime ( int x ) { // version non optimis\u00e9e for ( int i = 2 ; i < x ; ++ i ) { if ( x % i == 0 ) return false ; } return true ; } int main () { // future permet de lancer une fonction de mani\u00e8re asynchrone et // d'en r\u00e9cup\u00e9rer le r\u00e9sultat long n = 15 ; future < long > resultat1 = async ( factorielle , n ); cout << \"veuillez patienter pendant le calcul de la factorielle de \" << n ; chrono :: milliseconds tempo ( 100 ); while ( resultat1 . wait_for ( tempo ) == future_status :: timeout ) cout << '.' << flush ; cout << '\\n' ; cout << \"r\u00e9sultat : \" << resultat1 . get () << \" \\n \" ; future < bool > resultat2 = async ( is_prime , 444444443 ); cout << \"veuillez patienter pendant la v\u00e9rification\" ; while ( resultat2 . wait_for ( tempo ) == future_status :: timeout ) cout << '.' << flush ; cout << '\\n' ; cout << \"444444443 \" << ( resultat2 . get () ? \"est\" : \"n'est pas\" ) << \" premier. \\n \" ; return 0 ; }","title":"std::future et std::async"},{"location":"#mutex","text":"Un mutex est un objet verrouillable con\u00e7u pour prot\u00e9ger les acc\u00e8s aux sections critiques de code en emp\u00eachant d'autres threads de s'ex\u00e9cuter simultan\u00e9ment et d'acc\u00e9der aux m\u00eames emplacements m\u00e9moire. Lien : mutex #include <iostream> #include <thread> #include <mutex> // Chaque thread (tache) va faire ses COUNT boucles #define COUNT 5000 //#define MUTEX // avec ou sans mutex using namespace std ; int value_globale = 1 ; #ifdef MUTEX mutex m ; #endif // Avec mutex : g++ mutex.cpp -DMUTEX -lpthread // Sans mutex : g++ mutex.cpp -lpthread void increment () { int value = 0 ; for ( int i = 0 ; i < COUNT ; ++ i ) { #ifdef MUTEX m . lock (); #endif // R\u00e9cup\u00e8re la value value = value_globale ; // Incr\u00e9mente la value value += 1 ; // Stocke la value value_globale = value ; #ifdef MUTEX m . unlock (); #endif } } void decrement () { int value = 0 ; for ( int i = 0 ; i < COUNT ; ++ i ) { #ifdef MUTEX m . lock (); #endif // R\u00e9cup\u00e8re la value value = value_globale ; // D\u00e9cr\u00e9mente la value value -= 1 ; // Stocke la value value_globale = value ; #ifdef MUTEX m . unlock (); #endif } } int main () { setbuf ( stdout , NULL ); cout << \"Avant l'ex\u00e9cution des threads : value = \" << value_globale << \" (\" << COUNT << \" boucles) \\n \" ; thread t1 ( increment ); // cr\u00e9ation et lancement du thread thread t2 ( decrement ); // cr\u00e9ation et lancement du thread t1 . join (); // attendre la fin du thread t2 . join (); // attendre la fin du thread cout << \" \\n Apres l'ex\u00e9cution des threads : value = \" << value_globale << \" (\" << COUNT << \" boucles) \\n \" ; return 0 ; } Voir aussi : lock_guard lock_guard est un objet qui g\u00e8re un mutex en le gardant toujours verrouill\u00e9. mutex m ; void foo () { lock_guard < mutex > lock ( m ); // cr\u00e9ation et appel \u00e0 lock() // section critique ... } // destruction et appel \u00e0 unlock() Voir aussi : condition_variable","title":"Mutex"},{"location":"#stdref","text":"La fonction std::ref (dans <functional> ) retourne un objet de type std::reference_wrapper<T> qui est en fait une r\u00e9f\u00e9rence sur l'\u00e9l\u00e9ment. Lien : std::ref #include <iostream> #include <functional> #include <thread> using namespace std ; // $ g++ ref.cpp -lpthread void foo ( int & data ) { data = 42 ; } int main () { int i1 = 100 ; cout << \"i1 = \" << i1 << endl ; foo ( std :: ref ( i1 )); cout << \"i1 = \" << i1 << endl ; i1 = 100 ; cout << \"i1 = \" << i1 << endl ; //std::thread t1(foo, i1); // no works std :: thread t1 ( foo , std :: ref ( i1 )); // works t1 . join (); cout << \"i1 = \" << i1 << endl ; return 0 ; }","title":"std::ref"},{"location":"#les-tableaux-a-taille-fixe-array","text":"C++11 fournit le nouveau type de tableau std::array en tant que conteneur standard (d\u00e9fini dans l'en-t\u00eate <array> ). Contrairement aux autres conteneurs standards, les tableaux array ont une taille fixe. array fonctionne de la m\u00eame mani\u00e8re que les tableaux en C sauf qu'il permet d'\u00eatre copi\u00e9 (op\u00e9ration relativement co\u00fbteuse car c'est une copie de la totalit\u00e9 du bloc de m\u00e9moire) et peut s'utiliser explicitement en pointeur. Lien : array #include <iostream> #include <array> #define TAILLE 3 using namespace std ; int main () { // En C/C++ cout << \"-> En C/C++\" << endl ; int t1 [ TAILLE ] = { 10 , 20 , 30 }; cout << \"Elements du tableau t1 (avant) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t1 [ i ] << \" \" ; cout << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) ++ t1 [ i ]; cout << \"Elements du tableau t1 (apr\u00e8s) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t1 [ i ] << \" \" ; cout << endl ; cout << \"Elements du tableau t1 (apr\u00e8s) : \" << endl ; for ( int element : t1 ) cout << element << \" \" ; cout << endl ; cout << endl ; // En C++11 cout << \"-> En C++11\" << endl ; array < int , TAILLE > t2 { 10 , 20 , 30 }; cout << \"Elements du tableau t2 (avant) : \" << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) cout << t2 [ i ] << \" \" ; cout << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) ++ t2 [ i ]; cout << \"Elements du tableau t2 (apr\u00e8s) : \" << endl ; for ( int i = 0 ; i < t2 . size (); ++ i ) cout << t2 [ i ] << \" \" ; cout << endl ; cout << \"Elements du tableau t2 (apr\u00e8s) : \" << endl ; for ( int element : t2 ) cout << element << \" \" ; cout << endl ; // Avec un pointeur int * t3 = t2 . data (); // data() renvoie un pointeur vers le premier \u00e9l\u00e9ment du tableau // Dans array, les \u00e9l\u00e9ments du tableau sont stock\u00e9s dans des emplacements m\u00e9moire contigus, // le pointeur r\u00e9cup\u00e9r\u00e9 (ici t3) peut \u00eatre utilis\u00e9 pour acc\u00e9der \u00e0 n'importe quel \u00e9l\u00e9ment du tableau cout << \"Elements du tableau t2 (avec un pointeur) : \" << endl ; for ( int i = 0 ; i < TAILLE ; ++ i ) cout << t3 [ i ] << \" \" ; // cout << *(t3+i) << \" \"; cout << endl ; // Avec un it\u00e9rateur cout << \"Elements du tableau t2 (avec un it\u00e9rateur) : \" << endl ; //for(array<int,TAILLE>::iterator it = t2.begin(); it != t2.end(); ++it) for ( auto it = t2 . begin (); it != t2 . end (); ++ it ) cout << * it << \" \" ; cout << endl ; return 0 ; }","title":"Les tableaux \u00e0 taille fixe array"},{"location":"#les-listes-simplement-chainee","text":"forward_list est l'impl\u00e9mentation d'une liste simplement cha\u00een\u00e9e accessible seulement par sa t\u00eate ( front ). Lien : http://www.cplusplus.com/reference/forward_list/forward_list/[forward_list] #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > liste = { 10 , 20 , 30 , 40 , 50 }; cout << \"liste : \\n \" ; for ( int & element : liste ) cout << element << \" \" ; cout << '\\n' ; return 0 ; }","title":"Les listes simplement cha\u00een\u00e9e"},{"location":"#le-type-tuple","text":"Un tuple est une collection de dimension fixe d'objets de types diff\u00e9rents. Tout type d'objet peut \u00eatre \u00e9l\u00e9ment d'un tuple. Cette nouvelle fonctionnalit\u00e9 est impl\u00e9ment\u00e9e dans le nouvel en-t\u00eate <tuple> et b\u00e9n\u00e9ficie des extensions de C++11. Lien : tuple #include <iostream> #include <tuple> // cf. http://www.cplusplus.com/reference/tuple/tuple/ using namespace std ; int main () { typedef tuple < string , string , int , double > tuple_1 ; tuple_1 foo ( \"John\" , \"Smith\" , 50 , 1.87 ); cout << get < 0 > ( foo ) << \" \" << get < 1 > ( foo ) << endl ; cout << \"Nb elements du tuple : \" << tuple_size < tuple_1 >:: value << endl ; tuple < double , double , char > p1 ( 0. , 0. , 'A' ); cout << get < 2 > ( p1 ) << \" : \" << get < 0 > ( p1 ) << \",\" << get < 1 > ( p1 ) << endl ; get < 2 > ( p1 ) = 'B' ; cout << get < 2 > ( p1 ) << \" : \" << get < 0 > ( p1 ) << \",\" << get < 1 > ( p1 ) << endl ; auto bar = std :: make_tuple ( \"pi\" , 3.14 ); cout << get < 0 > ( bar ) << \" = \" << get < 1 > ( bar ) << endl ; return 0 ; }","title":"Le type Tuple"},{"location":"#tables-de-hachage","text":"Une table de hachage ( hash table ) est une structure de donn\u00e9es qui permet une association cl\u00e9-\u00e9l\u00e9ment. Il s'agit d'un tableau ne comportant pas d'ordre (contrairement \u00e0 un tableau ordinaire qui est index\u00e9 par des entiers). On acc\u00e8de \u00e0 chaque \u00e9l\u00e9ment de la table par sa cl\u00e9. L'acc\u00e8s s'effectue par une fonction de hachage qui transforme une cl\u00e9 en une valeur de hachage (un nombre) indexant les \u00e9l\u00e9ments de la table. Pour \u00e9viter les conflits de noms avec les biblioth\u00e8ques non standards qui ont leur propre impl\u00e9mentation des tables de hachage, on utilisera le pr\u00e9fixe unordered au lieu de hash . Il existe deux types de tables de hachage dans la STL : hash_set<K> : table de hachage simple, stocke seulement des cl\u00e9s de type K. hash_map<K,T> : table de hachage double, stocke des cl\u00e9s de type K associ\u00e9es \u00e0 des valeurs de type T. \u00c0 une cl\u00e9 donn\u00e9e ne peut \u00eatre stock\u00e9e qu'une seule valeur. Liens : hash_set hash_map Remarque : hash_set et hash_map font partie de la STL mais ne sont pas int\u00e9gr\u00e9s \u00e0 la biblioth\u00e8que standard C++. Les compilateurs GNU C++ et Visual C++ de Microsoft les ont quand m\u00eame impl\u00e9ment\u00e9s. Le standard C++11 propose des conteneurs similaires : unordered_set et unordered_map . Liens : unordered_set unordered_map #include <iostream> #include <string> #include <unordered_map> using namespace std ; int main () { unordered_map < string , string > hashtable ; //hashtable.emplace(\"www.wikipedia.fr\", \"78.109.84.114\"); //cout << \"Adresse IP : \" << hashtable[\"www.wikipedia.fr\"] << endl; hashtable . insert ( make_pair ( \"www.cplusplus.com\" , \"167.114.170.15\" )); hashtable . insert ( make_pair ( \"www.google.fr\" , \"216.58.204.67\" )); cout << \"Adresse IP de www.google.fr : \" << hashtable [ \"www.google.fr\" ] << endl << endl ; cout << \"La table : \" << endl ; for ( auto itr = hashtable . begin (); itr != hashtable . end (); itr ++ ) { cout << ( * itr ). first << \" -> \" << ( * itr ). second << endl ; } return 0 ; } On peut cr\u00e9er sa propre fonction de hachage avec un foncteur ( Function Object ) est un objet qui se comporte comme une fonction en surchargeant l'op\u00e9rateur () : #include <iostream> #include <string> #include <unordered_map> using namespace std ; // Foncteur de hachage class Hachage { public : size_t operator ()( const string & s ) const { cout << \"[hash : \" << hash < string > ()( s ) << \"]\" << endl ; return hash < string > ()( s ); } }; int main () { unordered_map < string , string , Hachage > hashtable ; hashtable . insert ( make_pair ( \"www.wikipedia.fr\" , \"78.109.84.114\" )); hashtable . insert ( make_pair ( \"www.cplusplus.com\" , \"167.114.170.15\" )); hashtable . insert ( make_pair ( \"www.google.fr\" , \"216.58.204.67\" )); cout << endl << \"La table : \" << endl ; for ( auto itr = hashtable . begin (); itr != hashtable . end (); itr ++ ) { cout << ( * itr ). first << \" -> \" << ( * itr ). second << endl ; } cout << endl ; cout << \"Adresse IP de www.google.fr : \" << hashtable [ \"www.google.fr\" ] << endl ; return 0 ; } On peut utiliser unordered_map avec ses propres classes \u00e0 condition de d\u00e9finir l'op\u00e9rateur == : #include <iostream> #include <string> #include <unordered_map> using namespace std ; class Fabricant { private : string nom ; public : Fabricant ( string nom ) { this -> nom = nom ; } string getNom () const { return nom ; } bool operator == ( const Fabricant & f ) const { return nom == f . nom ; } }; class Modele { private : string nom ; int annee ; public : Modele ( string nom , int annee ) { this -> nom = nom ; this -> annee = annee ; } string getNom () const { return nom ; } int getAnnee () const { return annee ; } bool operator == ( const Modele & m ) const { return ( nom == m . nom && annee == m . annee ); } }; class Hachage { public : size_t operator ()( const Modele & m ) const { return hash < string > ()( m . getNom ()) ^ hash < int > ()( m . getAnnee ()); } }; int main () { unordered_map < Modele , Fabricant , Hachage > catalogue ; Modele zoe ( \"Zoe\" , 2012 ); Modele megane3 ( \"Megane III\" , 2008 ); Modele clio3 ( \"Clio III\" , 2005 ); Modele bipper ( \"Bipper\" , 2007 ); Fabricant renault ( \"Renault\" ); Fabricant peugeot ( \"Peugeot\" ); catalogue . insert ( make_pair ( zoe , renault )); catalogue . insert ( make_pair ( megane3 , renault )); catalogue . insert ( make_pair ( clio3 , renault )); catalogue . insert ( make_pair ( bipper , peugeot )); for ( auto & itr : catalogue ) { cout << itr . second . getNom () << \" \" << itr . first . getNom () << \" \" << itr . first . getAnnee () << endl ; } return 0 ; }","title":"Tables de hachage"},{"location":"#nombres-pseudo-aleatoires","text":"La biblioth\u00e8que standard du C permet de g\u00e9n\u00e9rer des nombres pseudo-al\u00e9atoires gr\u00e2ce \u00e0 la fonction rand() . C++11 va fournir une mani\u00e8re diff\u00e9rente de g\u00e9n\u00e9rer les nombres pseudo-al\u00e9atoires : un moteur de g\u00e9n\u00e9ration, qui contient l'\u00e9tat du g\u00e9n\u00e9rateur et produit les nombres pseudo-al\u00e9atoires ; une distribution, qui d\u00e9termine les valeurs que le r\u00e9sultat peut prendre ainsi que sa loi de probabilit\u00e9. C++11 d\u00e9finit trois algorithmes de g\u00e9n\u00e9ration (linear_congruential, subtract with carry et mersenne_twister), chacun ayant des avantages et des inconv\u00e9nients et fournira un certain nombre de lois standard (uniform_int_distribution, bernoulli_distribution, ...). Lien : random #include <iostream> #include <random> #include <functional> // std::bind #include <chrono> using namespace std ; int main () { unsigned seed = std :: chrono :: system_clock :: now (). time_since_epoch (). count (); std :: uniform_int_distribution < int > distribution1 ( 1 , 6 ); // un d\u00e9 \u00e0 6 faces std :: default_random_engine default_engine ( seed ); int de = distribution1 ( default_engine ); // genere un nombre entre 1 et 6 cout << \"de = \" << de << '\\n' ; std :: uniform_int_distribution < int > distribution2 ( 0 , 99 ); std :: mt19937 engine ( seed ); auto generator = std :: bind ( distribution2 , engine ); int random = generator (); // genere un nombre entre 0 et 99 cout << \"random = \" << random << '\\n' ; return 0 ; }","title":"Nombres pseudo-al\u00e9atoires"},{"location":"#fonction-lambda","text":"Une lambda est une fonction possiblement anonyme et destin\u00e9e \u00e0 \u00eatre utilis\u00e9e localement. Liens : lambda Des fonctions somme toute lambdas Syntaxe : [zone de capture](param\u00e8tres de la lambda) -> type de retour { instructions } Exemple simpliste : int main () { []() -> void {}; return 0 ; } Exemples basiques : #include <algorithm> #include <iostream> #include <string> #include <vector> using namespace std ; int main () { // Exemple 1 auto lambda = []( string const & message ) -> void { cout << \"Message re\u00e7u : \" << message << endl ; }; lambda ( \"Hello !\" ); // Exemple 2 vector < string > const chaines { \"Un mot\" , \"Autre chose\" , \"Du blabla\" , \"Du texe\" , \"Des lettres\" }; for_each ( begin ( chaines ), end ( chaines ), []( string const & message ) -> void { cout << \"Message re\u00e7u : \" << message << endl ; }); return 0 ; } Les expressions Lambda (ou closure ) sont donc un bon moyen de passer du code en param\u00e8tre d'une fonction : // Exemple 3 vector < int > v { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; cout << \"v : \" ; for ( auto i : v ) // i est un int { cout << i << ' ' ; } cout << '\\n' ; unsigned int nbElementsPairs = 0 ; nbElementsPairs = count_if ( v . begin (), v . end (), []( auto x ) { return ! ( x % 2 ); }); cout << \"nbElementsPairs : \" << nbElementsPairs << endl ; Lien : count_if Remarque : Cette utilisation est simple et place le code du pr\u00e9dicat au bon endroit (sans avoir besoin de d\u00e9clarer une fonction pour cela). Les lambdas peuvent acc\u00e9der aux variables dans la port\u00e9e par r\u00e9f\u00e9rence ou par valeur : // Exemple 4 int borneMax = 5 ; unsigned int nbElements = 0 ; // acc\u00e8s aux variables par r\u00e9f\u00e9rence [&] nbElements = count_if ( v . begin (), v . end (), [ & ]( auto x ) { return ( x <= borneMax ); }); cout << \"nbElements : \" << nbElements << endl ; borneMax = 4 ; // acc\u00e8s aux variables par copie [=] nbElements = count_if ( v . begin (), v . end (), [ = ]( auto x ) { return ( x <= borneMax ); }); cout << \"nbElements : \" << nbElements << endl ;","title":"Fonction lambda"},{"location":"#stdfunction-et-stdmem_fn","text":"Le template std::function permet d'encapsuler un pointeur de fonction ou une lambda : #include <iostream> #include <string> #include <functional> using namespace std ; void foo ( string str ) { cout << \"message : \" << str << endl ; } int main () { std :: function < void ( string ) > fn_foo = foo ; fn_foo ( \"Hello world!\" ); return 0 ; } Le template std::mem_fn permet d'encapsuler un pointeur de m\u00e9thode (fonction membre) d'une classe : #include <iostream> #include <string> #include <functional> using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} void print ( int n = 1 ) const { for ( int i = 0 ; i < n ; ++ i ) cout << str << '\\n' ; } private : string str ; }; int main () { const Foo foo ( \"Hello world!\" ); auto fn1 = mem_fn ( & Foo :: print ); fn1 ( foo , 5 ); return 0 ; } Liens : std::function std::mem_fn","title":"std::function et std::mem_fn"},{"location":"#c14","text":"Lien : C++14","title":"C++14"},{"location":"#nombres-binaires","text":"Avec le C++14, il est d\u00e9sormais possible de sp\u00e9cifier des nombres binaires en utilisant le pr\u00e9fixe 0b ou 0B : #include <iostream> using namespace std ; int main () { int i = 0b01010101 ; int j = 0B10101010 ; cout << \"i = \" << i << \" (0x\" << hex << i << \")\" << endl ; cout << \"j = \" << j << \" (0x\" << hex << j << \")\" << endl ; return 0 ; }","title":"Nombres binaires"},{"location":"#separateur-de-chiffres","text":"Pour am\u00e9liorer la lisibilit\u00e9 : #include <iostream> using namespace std ; int main () { int i = 0b0101'0101 ; int j = 0b1010'1010 ; cout << \"i = \" << i << \" (0x\" << hex << i << \")\" << endl ; cout << \"j = \" << j << \" (0x\" << hex << j << \")\" << endl ; int un_milliard = 1'000'000'000 ; return 0 ; }","title":"S\u00e9parateur de chiffres"},{"location":"#c17","text":"Liens : De C++14 \u00e0 C++17 C++17 C++17 (en)","title":"C++17"},{"location":"#le-type-byte","text":"En C++17, std::byte (dans <cstddef> ) repr\u00e9sente un octet en m\u00e9moire. En C/C++, on utilisait le type char ou unsigned char . Attention, std::byte n'est pas un type caract\u00e8re et ni un type arithm\u00e9tique. Seuls op\u00e9rateurs au niveau du bit ont \u00e9t\u00e9 surcharg\u00e9s : les op\u00e9rateurs de d\u00e9calage comme << , >> , <<= , >>= les op\u00e9rateurs logiques comme | , & , ^ , ~ , |= , &= , ^= Le type byte n'est pas directement utilisable comme un entier sauf via la fonction std::to_integer<>() . Lien : std::byte #include <iostream> #include <cstddef> using namespace std ; // g++ -std=c++17 byte.cpp int main () { byte b1 { 10 }; byte b2 { 21 }; cout << \"b1 = \" << to_integer < int > ( b1 ) << endl ; b2 <<= 1 ; cout << \"b2 = \" << to_integer < int > ( b2 ) << endl ; byte b3 = b1 & b2 ; cout << \"b3 = b1 & b2\" << endl ; cout << \"b3 = \" << to_integer < int > ( b3 ) << endl ; int i1 = to_integer < int > ( b3 ); cout << \"i1 = \" << i1 << endl ; return 0 ; }","title":"Le type byte"},{"location":"#stdinvoke","text":"En C++17, la fonction std::invoke (dans <functional> ) permet d'appeler une fonction ou une m\u00e9thode en lui passant des arguments. Lien : std::invoke #include <iostream> #include <string> #include <functional> //$ g++ -std=c++17 invoke.cpp using namespace std ; class Foo { public : Foo ( const string & str ) : str ( str ) {} void print ( int n = 1 ) const { for ( int i = 0 ; i < n ; ++ i ) cout << str << '\\n' ; } private : string str ; }; void print ( string str ) { cout << \"message : \" << str << endl ; } int main () { // fonction invoke ( print , \"Hello world!\" ); const Foo foo ( \"Hello world!\" ); // m\u00e9thode invoke ( & Foo :: print , foo , 2 ); return 0 ; }","title":"std::invoke"},{"location":"#stdoptional","text":"En C++17, le type std::optional<T> peut contenir une valeur ou pas. On utilise la m\u00e9thode has_value() pour d\u00e9terminer s'il y a une valeur dans l'objet et value() pour la r\u00e9cup\u00e9rer. Lien : std::optional #include <iostream> #include <string> #include <optional> // $ g++ -std=c++17 optional.cpp using namespace std ; class Article { public : Article ( const string & libelle ) : libelle ( libelle ) {} Article ( const string & libelle , optional < double > prix ) : libelle ( libelle ), prix ( prix ) {} string getLibelle () const { return libelle ; } optional < double > getPrix () const { if ( prix . has_value ()) return prix ; else return {}; } private : string libelle ; optional < double > prix ; }; int main () { Article article1 ( \"De'Longhi Magnifica S\" , 295.0 ); Article article2 ( \"Philips EP2220\" ); cout << \"Article \" << article1 . getLibelle () << endl ; auto prix1 = article1 . getPrix (); if ( prix1 . has_value ()) { cout << \" prix : \" << prix1 . value () << \" euros\" << endl ; } else { cout << \" pas de prix pour cet article\" << endl ; } cout << \"Article \" << article2 . getLibelle () << endl ; auto prix2 = article2 . getPrix (); if ( prix2 . has_value ()) { cout << \" prix : \" << prix2 . value () << \" euros\" << endl ; } else { cout << \" pas de prix pour cet article\" << endl ; } return 0 ; }","title":"std::optional"},{"location":"#stdany","text":"En C++17, le type std::any peut contenir n'importe quel type ou aucune valeur. C'est l'\u00e9quivalent d'un void * type-safe . On peut utiliser la m\u00e9thode has_value() pour d\u00e9terminer s'il y a une valeur. Il existe aussi any_cast<T>() pour r\u00e9aliser des conversions vers des types T . type() retourne une r\u00e9f\u00e9rence sur le type type_info . Lien : std::any #include <iostream> #include <string> #include <any> // $ g++ -std=c++17 any.cpp using namespace std ; int main () { any a = 1 ; cout << a . type (). name () << \" -> \" << any_cast < int > ( a ) << '\\n' ; any s = string ( \"Hello world!\" ); cout << s . type (). name () << \" -> \" << any_cast < string > ( s ) << '\\n' ; return 0 ; }","title":"std::any"},{"location":"#c20","text":"Liens : C++20 C++20 (en)","title":"C++20"},{"location":"#wikipedia","text":"C++11 C++14 C++17 C++20","title":"Wikip\u00e9dia"},{"location":"#voir-aussi","text":"C++ - Sujets divers","title":"Voir aussi"}]}